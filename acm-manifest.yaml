# Copyright 2018 The Kubernetes Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Do not edit this file
# This file is autogenerated by scripts/generate.sh
#
# ----- config-sync-manifest.yaml -----
apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: acm-psp
spec:
  privileged: false
  volumes:
    - 'configMap'
    - 'downwardAPI'
    - 'emptyDir'
    - 'persistentVolumeClaim'
    - 'projected'
    - 'secret'
  # Block root privileges
  runAsUser:
    rule: 'MustRunAsNonRoot'
  seLinux:
    # seLinux is a required field, but most configurations don't use it and if we set it to anything
    # other than RunAsAny, then the host OS has to have the SELinux security module loaded.
    rule: 'RunAsAny'
  supplementalGroups:
    rule: 'MustRunAs'
    # This range allows all GIDs except for root, which is 0
    ranges:
      - min: 1
        max: 65535
  fsGroup:
    rule: 'MustRunAs'
    # This range allows all GIDs except for root, which is 0
    ranges:
      - min: 1
        max: 65535
---
# Custom Resource Definition for ClusterConfig
# which manages cluster level configs on the
# kubernetes cluster.
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: clusterconfigs.configmanagement.gke.io
  labels:
    configmanagement.gke.io/system: "true"
    configmanagement.gke.io/arch: "legacy"
spec:
  preserveUnknownFields: false
  group: configmanagement.gke.io
  scope: Cluster
  names:
    plural: clusterconfigs
    singular: clusterconfig
    kind: ClusterConfig
    shortNames:
    - cr
  versions:
  - name: v1
    served: true
    storage: true
    subresources:
      status: {}
    schema:
      openAPIV3Schema:
        type: object
        required:
        - spec
        properties:
          spec:
            # ClusterConfigSpec
            type: object
            properties:
              token:
                type: string
              importTime: # metav1.Time
                type: string
                format: date-time
                nullable: true
              resources:
                type: array
                items:
                  # GenericResources
                  type: object
                  required:
                  - kind
                  - versions
                  properties:
                    group:
                      type: string
                    kind:
                      type: string
                    versions:
                      type: array
                      items:
                        # GenericVersionResources
                        type: object
                        required:
                        - objects
                        - version
                        properties:
                          objects:
                            type: array
                            items:
                              type: object # runtime.RawExtension
                              x-kubernetes-embedded-resource: true
                              x-kubernetes-preserve-unknown-fields: true
                          version:
                            type: string
                        # /GenericVersionResources
                  # /GenericResources
            # /ClusterConfigSpec
          status:
            # ClusterConfigStatus
            type: object
            properties:
              token:
                type: string
              syncErrors:
                type: array
                items:
                  # ClusterConfigSyncError
                  type: object
                  properties:
                    sourcePath:
                      type: string
                    resourceName:
                      type: string
                    resourceNamespace:
                      type: string
                    resourceGVK: # schema.GroupVersionKind
                      type: object
                      properties:
                        Group:
                          type: string
                        Version:
                          type: string
                        Kind:
                          type: string
                    code:
                      type: string
                    errorMessage:
                      type: string
                    errorResources:
                      type: array
                      items:
                        type: object
                        properties:
                          sourcePath:
                            type: string
                          resourceName:
                            type: string
                          resourceNamespace:
                            type: string
                          resourceGVK:
                            type: object # schema.GroupVersionKind
                            properties:
                              Group:
                                type: string
                              Version:
                                type: string
                              Kind:
                                type: string
                  # /ClusterConfigSyncError
              syncTime: # metav1.Time
                type: string
                format: date-time
                nullable: true
              syncState:
                type: string
                enum:
                - ""
                - "synced"
                - "stale"
                - "error"
              resourceConditions:
                type: array
                items:
                  type: object
                  properties:
                    groupVersion:
                      type: string
                    kind:
                      type: string
                    namespacedName:
                      type: string
                    resourceState:
                      type: string
                    token:
                      type: string
                    reconcilingReasons:
                      type: array
                      items:
                        type: string
                    errors:
                      type: array
                      items:
                        type: string
            # /ClusterConfigStatus
---
# This is taken verbatim from:
# https://github.com/kubernetes/cluster-registry/blob/master/cluster-registry-crd.yaml
# If updating this file, please add this entire comment too.
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  labels:
    api: ""
    kubebuilder.k8s.io: 1.0.3
    configmanagement.gke.io/system: "true"
  name: clusters.clusterregistry.k8s.io
  annotations:
    # According to this PR https://github.com/kubernetes/enhancements/pull/1111
    # For group under k8s.io, this annotation is required to link to a PR where API is approved
    "api-approved.kubernetes.io": "https://github.com/kubernetes-retired/cluster-registry/pull/269"
spec:
  preserveUnknownFields: false
  group: clusterregistry.k8s.io
  names:
    kind: Cluster
    plural: clusters
  scope: Namespaced
  versions:
    - name: v1alpha1
      served: true
      storage: true
      schema:
        openAPIV3Schema:
          type: object
          properties:
            apiVersion:
              type: string
            kind:
              type: string
            metadata:
              type: object
            spec:
              type: object
              properties:
                authInfo:
                  type: object
                  properties:
                    controller:
                      type: object
                      properties:
                        kind:
                          type: string
                        name:
                          type: string
                        namespace:
                          type: string
                    user:
                      type: object
                      properties:
                        kind:
                          type: string
                        name:
                          type: string
                        namespace:
                          type: string
                kubernetesApiEndpoints:
                  type: object
                  properties:
                    caBundle:
                      format: byte
                      type: string
                    serverEndpoints:
                      type: array
                      items:
                        type: object
                        properties:
                          clientCIDR:
                            type: string
                          serverAddress:
                            type: string
            status:
              type: object
              properties:
                conditions:
                  type: array
                  items:
                    required:
                    - type
                    - status
                    type: object
                    properties:
                      lastHeartbeatTime:
                        format: date-time
                        type: string
                      lastTransitionTime:
                        format: date-time
                        type: string
                      message:
                        type: string
                      reason:
                        type: string
                      status:
                        type: string
                      type:
                        type: string
---
# Custom Resource Definition for a Cluster Selector.
# This is by and large identical spec to NamespaceSelector, but used in a
# different context.
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: clusterselectors.configmanagement.gke.io
  labels:
    configmanagement.gke.io/system: "true"
spec:
  preserveUnknownFields: false
  group: configmanagement.gke.io
  scope: Cluster
  names:
    plural: clusterselectors
    singular: clusterselector
    kind: ClusterSelector
  versions:
    - name: v1
      served: true
      storage: true
      schema:
        # openAPIV3Schema is the schema for validating custom objects.
        # TODO(frankf): Complete and tests this once 1.11 beta is out.
        openAPIV3Schema:
          type: object
          required:
          - spec
          properties:
            spec:
              # ClusterSelectorSpec
              type: object
              required:
              - selector
              properties:
                selector:
                  type: object # metav1.LabelSelector
                  x-kubernetes-preserve-unknown-fields: true
              # /ClusterSelectorSpec
---
apiVersion: v1
kind: LimitRange
metadata:
  name: container-limits
  namespace: config-management-system
  labels:
    configmanagement.gke.io/system: "true"
spec:
  limits:
  - defaultRequest:
      cpu: "10m"
      memory: "10Mi"
    default:
      cpu: "1"
      memory: "200Mi"
    type: Container
---
# Custom Resource Definition for a declaring the hierarchy mode for resources
# in the source of truth.
# See pkg/api/configmanagement/v1alpha1/types.go for the CRD struct spec.
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: hierarchyconfigs.configmanagement.gke.io
  labels:
    configmanagement.gke.io/system: "true"
spec:
  preserveUnknownFields: false
  group: configmanagement.gke.io
  scope: Cluster
  names:
    plural: hierarchyconfigs
    singular: hierarchyconfig
    kind: HierarchyConfig
  versions:
    - name: v1
      served: true
      storage: true
      schema:
        openAPIV3Schema:
          type: object
          properties:
            spec:
              type: object
              x-kubernetes-preserve-unknown-fields: true
            status:
              type: object
              x-kubernetes-preserve-unknown-fields: true
---
# Nomos importer service account
apiVersion: v1
kind: ServiceAccount
metadata:
  name: importer
  namespace: config-management-system
  labels:
    configmanagement.gke.io/system: "true"
    configmanagement.gke.io/arch: "legacy"
---
# Importer needs to run as cluster-admin in order to be able to set RBAC
# permissions due to the restriction that you must have a permission in order
# to set it. This seems fine given that the importer is effectively administering
# the cluster.
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: configmanagement.gke.io:importer
  labels:
    configmanagement.gke.io/system: "true"
    configmanagement.gke.io/arch: "legacy"
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  # Note that running as cluster-admin means the SA does not need a PodSecurityPolicy.
  name: cluster-admin
subjects:
- kind: ServiceAccount
  name: importer
  namespace: config-management-system
---
# Nomos monitor service account
apiVersion: v1
kind: ServiceAccount
metadata:
  name: monitor
  namespace: config-management-system
  labels:
    configmanagement.gke.io/system: "true"
    configmanagement.gke.io/arch: "legacy"
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: configmanagement.gke.io:monitor
  labels:
    configmanagement.gke.io/system: "true"
    configmanagement.gke.io/arch: "legacy"
rules:
- apiGroups:
  - configmanagement.gke.io
  resources:
  - namespaceconfigs
  - clusterconfigs
  - repos
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - policy
  resources:
    - podsecuritypolicies
  resourceNames:
    - acm-psp
  verbs:
    - use
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: configmanagement.gke.io:monitor
  labels:
    configmanagement.gke.io/system: "true"
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: configmanagement.gke.io:monitor
subjects:
- kind: ServiceAccount
  name: monitor
  namespace: config-management-system
---
# Custom Resource Definition for a NamespaceConfig
# which is a resource containing information about
# a cluster and the policies attached to it.
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: namespaceconfigs.configmanagement.gke.io
  labels:
    configmanagement.gke.io/arch: "legacy"
    configmanagement.gke.io/system: "true"
spec:
  preserveUnknownFields: false
  group: configmanagement.gke.io
  scope: Cluster
  names:
    plural: namespaceconfigs
    singular: namespaceconfig
    kind: NamespaceConfig
    shortNames:
    - nc
  versions:
  - name: v1
    served: true
    storage: true
    subresources:
      status: {}
    schema:
      openAPIV3Schema:
        type: object
        required:
        - spec
        properties:
          spec:
            # NamespaceConfigSpec
            type: object
            properties:
              token:
                type: string
              importTime: # metav1.Time
                type: string
                format: date-time
                nullable: true
              resources:
                type: array
                items:
                  # GenericResources
                  type: object
                  required:
                  - kind
                  - versions
                  properties:
                    group:
                      type: string
                    kind:
                      type: string
                    versions:
                      type: array
                      items:
                        # GenericVersionResources
                        type: object
                        required:
                        - objects
                        - version
                        properties:
                          objects:
                            type: array
                            items:
                              type: object # runtime.RawExtension
                              x-kubernetes-embedded-resource: true
                              x-kubernetes-preserve-unknown-fields: true
                          version:
                            type: string
                        # /GenericVersionResources
                  # /GenericResources
              deleteSyncedTime: # metaV1.Time
                type: string
                format: date-time
                nullable: true
            # /NamespaceConfigSpec
          status:
            # NamespaceConfigStatus
            type: object
            properties:
              token:
                type: string
              syncErrors:
                type: array
                items:
                  # NamespaceConfigSyncError
                  type: object
                  x-kubernetes-preserve-unknown-fields: true
                  properties:
                    sourceName:
                      type: string
                    resourceName:
                      type: string
                    resourceKind:
                      type: string
                    resourceAPI:
                      type: string
                    errorMessage:
                      type: string
                  # /NamespaceConfigSyncError
              syncTime: # metav1.Time
                type: string
                format: date-time
                nullable: true
              syncState:
                type: string
                enum:
                - ""
                - "synced"
                - "stale"
                - "error"
              resourceConditions:
                type: array
                items:
                  type: object
                  properties:
                    groupVersion:
                      type: string
                    kind:
                      type: string
                    namespacedName:
                      type: string
                    resourceState:
                      type: string
                    token:
                      type: string
                    reconcilingReasons:
                      type: array
                      items:
                        type: string
                    errors:
                      type: array
                      items:
                        type: string
            # /NamespaceConfigStatus
---
# Custom Resource Definition for a Namespace Selector.
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: namespaceselectors.configmanagement.gke.io
  labels:
    configmanagement.gke.io/system: "true"
spec:
  preserveUnknownFields: false
  group: configmanagement.gke.io
  scope: Cluster
  names:
    plural: namespaceselectors
    singular: namespaceselector
    kind: NamespaceSelector
  versions:
    - name: v1
      served: true
      storage: true
      schema:
        # openAPIV3Schema is the schema for validating custom objects.
        # TODO(frankf): Complete and tests this once 1.11 beta is out.
        openAPIV3Schema:
          type: object
          required:
          - spec
          properties:
            spec:
              # NamespaceSelectorSpec
              type: object
              required:
              - selector
              properties:
                selector:
                  type: object # metav1.LabelSelector
                  x-kubernetes-preserve-unknown-fields: true
              # /NamespaceSelectorSpec
---
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: repos.configmanagement.gke.io
  labels:
    configmanagement.gke.io/system: "true"
    configmanagement.gke.io/arch: "legacy"
spec:
  preserveUnknownFields: false
  group: configmanagement.gke.io
  scope: Cluster
  names:
    plural: repos
    singular: repo
    kind: Repo
  versions:
  - name: v1
    served: true
    storage: true
    subresources:
      status: {}
    schema:
      # openAPIV3Schema is the schema for validating custom objects
      # TODO(phillipao): Complete and test when 1.11 beta is out.
      openAPIV3Schema:
        type: object
        required:
        - spec
        properties:
          spec:
            # RepoSpec
            type: object
            required:
            - version
            properties:
              version:
                type: string
            # /RepoSpec
          status:
            # RepoStatus
            type: object
            properties:
              source:
                type: object
                properties:
                  token:
                    type: string
                  errors:
                    type: array
                    items:
                      type: object
                      properties:
                        sourcePath:
                          type: string
                        resourceName:
                          type: string
                        resourceNamespace:
                          type: string
                        resourceGVK:
                          type: object
                          properties:
                            Group:
                              type: string
                            Version:
                              type: string
                            Kind:
                              type: string
                        code:
                          type: string
                        errorMessage:
                          type: string
                        errorResources:
                          type: array
                          items:
                            type: object
                            properties:
                              sourcePath:
                                type: string
                                resourceName:
                                  type: string
                                resourceNamespace:
                                  type: string
                                resourceGVK:
                                  type: object
                                  properties:
                                    Group:
                                      type: string
                                    Version:
                                      type: string
                                    Kind:
                                      type: string
              import:
                type: object
                properties:
                  token:
                    type: string
                  lastUpdate: # metav1.Time
                    type: string
                    format: date-time
                    nullable: true
                  errors:
                    type: array
                    items:
                      type: object
                      properties:
                        sourcePath:
                          type: string
                        resourceName:
                          type: string
                        resourceNamespace:
                          type: string
                        resourceGVK:
                          type: object
                          properties:
                            Group:
                              type: string
                            Version:
                              type: string
                            Kind:
                              type: string
                        code:
                          type: string
                        errorMessage:
                          type: string
                        errorResources:
                          type: array
                          items:
                            type: object
                            properties:
                              sourcePath:
                                type: string
                                resourceName:
                                  type: string
                                resourceNamespace:
                                  type: string
                                resourceGVK:
                                  type: object
                                  properties:
                                    Group:
                                      type: string
                                    Version:
                                      type: string
                                    Kind:
                                      type: string
              sync:
                type: object
                properties:
                  latestToken:
                    type: string
                  lastUpdate: # metav1.Time
                    type: string
                    format: date-time
                    nullable: true
                  inProgress:
                    type: array
                    items:
                      type: object
                      properties:
                        token:
                          type: string
                        errors:
                          type: array
                          items:
                            type: object
                            properties:
                              sourcePath:
                                type: string
                              resourceName:
                                type: string
                              resourceNamespace:
                                type: string
                              resourceGVK:
                                type: object
                                properties:
                                  Group:
                                    type: string
                                  Version:
                                    type: string
                                  Kind:
                                    type: string
                              code:
                                type: string
                              errorMessage:
                                type: string
                              errorResources:
                                type: array
                                items:
                                  type: object
                                  properties:
                                    sourcePath:
                                      type: string
                                      resourceName:
                                        type: string
                                      resourceNamespace:
                                        type: string
                                      resourceGVK:
                                        type: object
                                        properties:
                                          Group:
                                            type: string
                                          Version:
                                            type: string
                                          Kind:
                                            type: string
                  resourceConditions:
                    type: array
                    items:
                      type: object
                      properties:
                        groupVersion:
                          type: string
                        kind:
                          type: string
                        namespacedName:
                          type: string
                        resourceState:
                          type: string
                        token:
                          type: string
                        reconcilingReasons:
                          type: array
                          items:
                            type: string
                        errors:
                          type: array
                          items:
                            type: string
            # /RepoStatus
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: configsync.gke.io:ns-reconciler
  labels:
    configmanagement.gke.io/system: "true"
    configmanagement.gke.io/arch: "csmr"
rules:
- apiGroups: ["configsync.gke.io"]
  resources: ["reposyncs"]
  verbs: ["get"]
- apiGroups: ["configsync.gke.io"]
  resources: ["reposyncs/status"]
  verbs: ["get","list","update"]
- apiGroups: ["kpt.dev"]
  resources: ["resourcegroups"]
  verbs: ["*"]
- apiGroups:
  - policy
  resources:
  - podsecuritypolicies
  resourceNames:
  - acm-psp
  verbs:
  - use
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: otel-agent
  namespace: config-management-system
  labels:
    app: opentelemetry
    component: otel-agent
    configmanagement.gke.io/system: "true"
    configmanagement.gke.io/arch: "csmr"
data:
  otel-agent-config.yaml: |
    receivers:
      opencensus:
    exporters:
      opencensus:
        endpoint: otel-collector.config-management-monitoring:55678
        insecure: true
    processors:
      batch:
    extensions:
      health_check:
    service:
      extensions: [health_check]
      pipelines:
        metrics:
          receivers: [opencensus]
          processors: [batch]
          exporters: [opencensus]
---
# Nomos policy controller PSP
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: configmanagement.gke.io:policy-controller-psp
rules:
- apiGroups:
  - policy
  resources:
  - podsecuritypolicies
  resourceNames:
  - acm-psp
  verbs:
  - use
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: configmanagement.gke.io:policy-controller-psp
  labels:
    policycontroller.configmanagement.gke.io: "true"
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: configmanagement.gke.io:policy-controller-psp
subjects:
- kind: ServiceAccount
  name: gatekeeper-admin
  namespace: gatekeeper-system
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: reconciler-manager
  namespace: config-management-system
  labels:
    configmanagement.gke.io/system: "true"
    configmanagement.gke.io/arch: "csmr"
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: configsync.gke.io:reconciler-manager
  labels:
    configmanagement.gke.io/system: "true"
    configmanagement.gke.io/arch: "csmr"
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  # In order to provision the root reconciler as cluster-admin, the reconciler
  # manager also needs to be cluster-admin. See b/167259858 for more details.
  name: cluster-admin
subjects:
- kind: ServiceAccount
  name: reconciler-manager
  namespace: config-management-system
---
# Custom Resource Definition for a RepoSync.
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  annotations:
    controller-gen.kubebuilder.io/version: v0.2.5
  labels:
    configmanagement.gke.io/system: "true"
    configmanagement.gke.io/arch: "csmr"
  name: reposyncs.configsync.gke.io
spec:
  preserveUnknownFields: false
  group: configsync.gke.io
  names:
    kind: RepoSync
    listKind: RepoSyncList
    plural: reposyncs
    singular: reposync
  scope: Namespaced
  versions:
  - additionalPrinterColumns:
    - jsonPath: .status.rendering.commit
      name: RenderingCommit
      type: string
    - jsonPath: .status.source.commit
      name: SourceCommit
      type: string
    - jsonPath: .status.sync.commit
      name: SyncCommit
      type: string
    name: v1alpha1
    served: true
    storage: false
    schema:
      openAPIV3Schema:
        description: RepoSync is the Schema for the reposyncs API
        type: object
        properties:
          apiVersion:
            description: 'APIVersion defines the versioned schema of this representation
                     of an object. Servers should convert recognized schemas to the latest
                     internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
            type: string
          kind:
            description: 'Kind is a string value representing the REST resource this
                     object represents. Servers may infer this from the endpoint the client
                     submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
            type: string
          metadata:
            type: object
          spec:
            description: RepoSyncSpec defines the desired state of a RepoSync.
            type: object
            properties:
              git:
                description: git contains configuration specific to importing policies
                  from a Git repo.
                required:
                - auth
                - repo
                type: object
                properties:
                  auth:
                    description: auth is the type of secret configured for access to
                      the Git repo. Must be one of ssh, cookiefile, gcenode, token,
                      or none. Required. The validation of this is case-sensitive. Required.
                    pattern: ^(ssh|cookiefile|gcenode|gcpserviceaccount|token|none)$
                    type: string
                  branch:
                    description: 'branch is the git branch to checkout. Default: "master".'
                    type: string
                  dir:
                    description: 'dir is the absolute path of the directory that contains
                             the local config.  Default: the root directory of the repo.'
                    type: string
                  gcpServiceAccountEmail:
                    description: 'gcpServiceAccountEmail specifies the GCP service account
                             used to annotate the RepoSync controller Kubernetes Service
                             Account. Note: The field is used when spec.git.auth: gcpserviceaccount.'
                    type: string
                  noSSLVerify:
                    description: 'noSSLVerify specifies whether to enable or disable
                      the SSL certificate verification. Default: false. If noSSLVerify
                      is set to true, it tells Git to skip the SSL certificate verification.'
                    type: boolean
                  period:
                    description: 'period is the time duration in seconds between consecutive
                             syncs.  Default: 15 seconds. Note to developers that customers
                             specify this value using string (https://golang.org/pkg/time/#Duration.String)
                             like "3s" in their Custom Resource YAML. However, time.Duration
                             is at a nanosecond granularity, and it''s easy to introduce a
                             bug where it looks like the code is dealing with seconds but its
                             actually nanoseconds (or vice versa).'
                    type: string
                  proxy:
                    description: proxy is a struct that contains options for configuring
                      access to the Git repo via a proxy. Only has an effect when secretType
                      is one of ("cookiefile", "none"). Optional.
                    type: string
                  repo:
                    description: repo is the git repository URL to sync from. Required.
                    type: string
                  revision:
                    description: 'revision is the git revision (tag, ref or commit)
                             to fetch. Default: "HEAD".'
                    type: string
                  secretRef:
                    description: secretRef is the secret used to connect to the Git
                      source of truth.
                    properties:
                      name:
                        description: name represents the secret name.
                        type: string
                    type: object
              override:
                description: override allows to override the settings for a namespace reconciler.
                nullable: true
                properties:
                  gitSyncDepth:
                    description: gitSyncDepth allows one to override the number of git
                      commits to fetch. Must be no less than 0. Config Sync would do
                      a full clone if this field is 0, and a shallow clone if this field
                      is greater than 0. If this field is not provided, Config Sync
                      would configure it automatically.
                    format: int64
                    minimum: 0
                    type: integer
                  resources:
                    description: resources allow one to override the resource requirements
                      for the containers in a reconciler pod.
                    items:
                      description: ContainerResourcesSpec allows to override the resource
                        requirements for a container
                      properties:
                        containerName:
                          description: containerName specifies the name of a container
                            whose resource requirements will be overriden. Must be "reconciler"
                            or "git-sync".
                          pattern: ^(reconciler|git-sync|hydration-controller)$
                          type: string
                        cpuLimit:
                          anyOf:
                          - type: integer
                          - type: string
                          description: cpuLimit allows one to override the CPU limit
                            of a container
                          pattern: ^(\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))))?$
                          x-kubernetes-int-or-string: true
                        memoryLimit:
                          anyOf:
                          - type: integer
                          - type: string
                          description: memoryLimit allows one to override the memory
                            limit of a container
                          pattern: ^(\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))))?$
                          x-kubernetes-int-or-string: true
                      type: object
                    type: array
                type: object
              sourceFormat:
                description: "sourceFormat specifies how the repository is formatted.
                         See documentation for specifics of what these options do. \n Must
                         be unstructured. Optional. Set to unstructured if not specified. \n
                         The validation of this is case-sensitive."
                pattern: ^(unstructured|)$
                type: string
          status:
            description: RepoSyncStatus defines the observed state of a RepoSync.
            type: object
            x-kubernetes-preserve-unknown-fields: true
    subresources:
      status: {}
  - additionalPrinterColumns:
    - jsonPath: .status.rendering.commit
      name: RenderingCommit
      type: string
    - jsonPath: .status.source.commit
      name: SourceCommit
      type: string
    - jsonPath: .status.sync.commit
      name: SyncCommit
      type: string
    name: v1beta1
    served: true
    storage: true
    schema:
      openAPIV3Schema:
        description: RepoSync is the Schema for the reposyncs API
        type: object
        properties:
          apiVersion:
            description: 'APIVersion defines the versioned schema of this representation
                     of an object. Servers should convert recognized schemas to the latest
                     internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
            type: string
          kind:
            description: 'Kind is a string value representing the REST resource this
                     object represents. Servers may infer this from the endpoint the client
                     submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
            type: string
          metadata:
            type: object
          spec:
            description: RepoSyncSpec defines the desired state of a RepoSync.
            type: object
            properties:
              git:
                description: git contains configuration specific to importing policies
                  from a Git repo.
                required:
                - auth
                - repo
                type: object
                properties:
                  auth:
                    description: auth is the type of secret configured for access to
                      the Git repo. Must be one of ssh, cookiefile, gcenode, token,
                      or none. Required. The validation of this is case-sensitive. Required.
                    pattern: ^(ssh|cookiefile|gcenode|gcpserviceaccount|token|none)$
                    type: string
                  branch:
                    description: 'branch is the git branch to checkout. Default: "master".'
                    type: string
                  dir:
                    description: 'dir is the absolute path of the directory that contains
                             the local config.  Default: the root directory of the repo.'
                    type: string
                  gcpServiceAccountEmail:
                    description: 'gcpServiceAccountEmail specifies the GCP service account
                             used to annotate the RepoSync controller Kubernetes Service
                             Account. Note: The field is used when spec.git.auth: gcpserviceaccount.'
                    type: string
                  noSSLVerify:
                    description: 'noSSLVerify specifies whether to enable or disable
                      the SSL certificate verification. Default: false. If noSSLVerify
                      is set to true, it tells Git to skip the SSL certificate verification.'
                    type: boolean
                  period:
                    description: 'period is the time duration in seconds between consecutive
                             syncs.  Default: 15 seconds. Note to developers that customers
                             specify this value using string (https://golang.org/pkg/time/#Duration.String)
                             like "3s" in their Custom Resource YAML. However, time.Duration
                             is at a nanosecond granularity, and it''s easy to introduce a
                             bug where it looks like the code is dealing with seconds but its
                             actually nanoseconds (or vice versa).'
                    type: string
                  proxy:
                    description: proxy is a struct that contains options for configuring
                      access to the Git repo via a proxy. Only has an effect when secretType
                      is one of ("cookiefile", "none"). Optional.
                    type: string
                  repo:
                    description: repo is the git repository URL to sync from. Required.
                    type: string
                  revision:
                    description: 'revision is the git revision (tag, ref or commit)
                             to fetch. Default: "HEAD".'
                    type: string
                  secretRef:
                    description: secretRef is the secret used to connect to the Git
                      source of truth.
                    properties:
                      name:
                        description: name represents the secret name.
                        type: string
                    type: object
              override:
                description: override allows to override the settings for a namespace reconciler.
                nullable: true
                properties:
                  gitSyncDepth:
                    description: gitSyncDepth allows one to override the number of git
                      commits to fetch. Must be no less than 0. Config Sync would do
                      a full clone if this field is 0, and a shallow clone if this field
                      is greater than 0. If this field is not provided, Config Sync
                      would configure it automatically.
                    format: int64
                    minimum: 0
                    type: integer
                  resources:
                    description: resources allow one to override the resource requirements
                      for the containers in a reconciler pod.
                    items:
                      description: ContainerResourcesSpec allows to override the resource
                        requirements for a container
                      properties:
                        containerName:
                          description: containerName specifies the name of a container
                            whose resource requirements will be overriden. Must be "reconciler"
                            or "git-sync".
                          pattern: ^(reconciler|git-sync|hydration-controller)$
                          type: string
                        cpuLimit:
                          anyOf:
                          - type: integer
                          - type: string
                          description: cpuLimit allows one to override the CPU limit
                            of a container
                          pattern: ^(\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))))?$
                          x-kubernetes-int-or-string: true
                        memoryLimit:
                          anyOf:
                          - type: integer
                          - type: string
                          description: memoryLimit allows one to override the memory
                            limit of a container
                          pattern: ^(\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))))?$
                          x-kubernetes-int-or-string: true
                      type: object
                    type: array
                type: object
              sourceFormat:
                description: "sourceFormat specifies how the repository is formatted.
                         See documentation for specifics of what these options do. \n Must
                         be unstructured. Optional. Set to unstructured if not specified. \n
                         The validation of this is case-sensitive."
                pattern: ^(unstructured|)$
                type: string
          status:
            description: RepoSyncStatus defines the observed state of a RepoSync.
            type: object
            x-kubernetes-preserve-unknown-fields: true
    subresources:
      status: {}
---
# Custom Resource Definition for a RootSync.
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  annotations:
    controller-gen.kubebuilder.io/version: v0.2.5
  labels:
    configmanagement.gke.io/system: "true"
    configmanagement.gke.io/arch: "csmr"
  name: rootsyncs.configsync.gke.io
spec:
  preserveUnknownFields: false
  group: configsync.gke.io
  names:
    kind: RootSync
    listKind: RootSyncList
    plural: rootsyncs
    singular: rootsync
  scope: Namespaced
  versions:
  - additionalPrinterColumns:
    - jsonPath: .status.rendering.commit
      name: RenderingCommit
      type: string
    - jsonPath: .status.source.commit
      name: SourceCommit
      type: string
    - jsonPath: .status.sync.commit
      name: SyncCommit
      type: string
    name: v1alpha1
    served: true
    storage: false
    schema:
      openAPIV3Schema:
        description: RootSync is the Schema for the rootsyncs API
        type: object
        properties:
          apiVersion:
            description: 'APIVersion defines the versioned schema of this representation
                  of an object. Servers should convert recognized schemas to the latest
                  internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
            type: string
          kind:
            description: 'Kind is a string value representing the REST resource this
                  object represents. Servers may infer this from the endpoint the client
                  submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
            type: string
          metadata:
            type: object
          spec:
            description: RootSyncSpec defines the desired state of RootSync
            type: object
            properties:
              git:
                description: git contains configuration specific to importing resources
                  from a Git repo.
                required:
                - auth
                - repo
                type: object
                properties:
                  auth:
                    description: auth is the type of secret configured for access to
                      the Git repo. Must be one of ssh, cookiefile, gcenode, token,
                      or none. Required. The validation of this is case-sensitive. Required.
                    pattern: ^(ssh|cookiefile|gcenode|gcpserviceaccount|token|none)$
                    type: string
                  branch:
                    description: 'branch is the git branch to checkout. Default: "master".'
                    type: string
                  dir:
                    description: 'dir is the absolute path of the directory that contains
                          the local config.  Default: the root directory of the repo.'
                    type: string
                  gcpServiceAccountEmail:
                    description: 'gcpServiceAccountEmail specifies the GCP service account
                          used to annotate the RootSync controller Kubernetes Service
                          Account. Note: The field is used when spec.git.auth: gcpserviceaccount.'
                    type: string
                  noSSLVerify:
                    description: 'noSSLVerify specifies whether to enable or disable
                      the SSL certificate verification. Default: false. If noSSLVerify
                      is set to true, it tells Git to skip the SSL certificate verification.'
                    type: boolean
                  period:
                    description: 'period is the time duration in seconds between consecutive
                          syncs.  Default: 15 seconds. Note to developers that customers
                          specify this value using string (https://golang.org/pkg/time/#Duration.String)
                          like "3s" in their Custom Resource YAML. However, time.Duration
                          is at a nanosecond granularity, and it''s easy to introduce a
                          bug where it looks like the code is dealing with seconds but its
                          actually nanoseconds (or vice versa).'
                    type: string
                  proxy:
                    description: proxy is a struct that contains options for configuring
                      access to the Git repo via a proxy. Only has an effect when secretType
                      is one of ("cookiefile", "none"). Optional.
                    type: string
                  repo:
                    description: repo is the git repository URL to sync from. Required.
                    type: string
                  revision:
                    description: 'revision is the git revision (tag, ref or commit)
                          to fetch. Default: "HEAD".'
                    type: string
                  secretRef:
                    description: secretRef is the secret used to connect to the Git
                      source of truth.
                    properties:
                      name:
                        description: name represents the secret name.
                        type: string
                    type: object
              override:
                description: override allows to override the settings for a root reconciler.
                nullable: true
                properties:
                  gitSyncDepth:
                    description: gitSyncDepth allows one to override the number of git
                      commits to fetch. Must be no less than 0. Config Sync would do
                      a full clone if this field is 0, and a shallow clone if this field
                      is greater than 0. If this field is not provided, Config Sync
                      would configure it automatically.
                    format: int64
                    minimum: 0
                    type: integer
                  resources:
                    description: resources allow one to override the resource requirements
                      for the containers in a reconciler pod.
                    items:
                      description: ContainerResourcesSpec allows to override the resource
                        requirements for a container
                      properties:
                        containerName:
                          description: containerName specifies the name of a container
                            whose resource requirements will be overriden. Must be "reconciler"
                            or "git-sync".
                          pattern: ^(reconciler|git-sync|hydration-controller)$
                          type: string
                        cpuLimit:
                          anyOf:
                          - type: integer
                          - type: string
                          description: cpuLimit allows one to override the CPU limit
                            of a container
                          pattern: ^(\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))))?$
                          x-kubernetes-int-or-string: true
                        memoryLimit:
                          anyOf:
                          - type: integer
                          - type: string
                          description: memoryLimit allows one to override the memory
                            limit of a container
                          pattern: ^(\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))))?$
                          x-kubernetes-int-or-string: true
                      type: object
                    type: array
                type: object
              sourceFormat:
                description: "sourceFormat specifies how the repository is formatted.
                      See documentation for specifics of what these options do. \n Must
                      be one of hierarchy, unstructured. Optional. Set to hierarchy if not
                      specified. \n The validation of this is case-sensitive."
                pattern: ^(hierarchy|unstructured|)$
                type: string
          status:
            description: RootSyncStatus defines the observed state of RootSync
            type: object
            x-kubernetes-preserve-unknown-fields: true
    subresources:
      status: {}
  - additionalPrinterColumns:
    - jsonPath: .status.rendering.commit
      name: RenderingCommit
      type: string
    - jsonPath: .status.source.commit
      name: SourceCommit
      type: string
    - jsonPath: .status.sync.commit
      name: SyncCommit
      type: string
    name: v1beta1
    served: true
    storage: true
    schema:
      openAPIV3Schema:
        description: RootSync is the Schema for the rootsyncs API
        type: object
        properties:
          apiVersion:
            description: 'APIVersion defines the versioned schema of this representation
                      of an object. Servers should convert recognized schemas to the latest
                      internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
            type: string
          kind:
            description: 'Kind is a string value representing the REST resource this
                      object represents. Servers may infer this from the endpoint the client
                      submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
            type: string
          metadata:
            type: object
          spec:
            description: RootSyncSpec defines the desired state of RootSync
            type: object
            properties:
              git:
                description: git contains configuration specific to importing policies
                  from a Git repo.
                required:
                - auth
                - repo
                type: object
                properties:
                  auth:
                    description: auth is the type of secret configured for access to
                      the Git repo. Must be one of ssh, cookiefile, gcenode, token,
                      or none. Required. The validation of this is case-sensitive. Required.
                    pattern: ^(ssh|cookiefile|gcenode|gcpserviceaccount|token|none)$
                    type: string
                  branch:
                    description: 'branch is the git branch to checkout. Default: "master".'
                    type: string
                  dir:
                    description: 'dir is the absolute path of the directory that contains
                              the local config.  Default: the root directory of the repo.'
                    type: string
                  gcpServiceAccountEmail:
                    description: 'gcpServiceAccountEmail specifies the GCP service account
                              used to annotate the RootSync controller Kubernetes Service
                              Account. Note: The field is used when spec.git.auth: gcpserviceaccount.'
                    type: string
                  noSSLVerify:
                    description: 'noSSLVerify specifies whether to enable or disable
                      the SSL certificate verification. Default: false. If noSSLVerify
                      is set to true, it tells Git to skip the SSL certificate verification.'
                    type: boolean
                  period:
                    description: 'period is the time duration in seconds between consecutive
                              syncs.  Default: 15 seconds. Note to developers that customers
                              specify this value using string (https://golang.org/pkg/time/#Duration.String)
                              like "3s" in their Custom Resource YAML. However, time.Duration
                              is at a nanosecond granularity, and it''s easy to introduce a
                              bug where it looks like the code is dealing with seconds but its
                              actually nanoseconds (or vice versa).'
                    type: string
                  proxy:
                    description: proxy is a struct that contains options for configuring
                      access to the Git repo via a proxy. Only has an effect when secretType
                      is one of ("cookiefile", "none"). Optional.
                    type: string
                  repo:
                    description: repo is the git repository URL to sync from. Required.
                    type: string
                  revision:
                    description: 'revision is the git revision (tag, ref or commit)
                              to fetch. Default: "HEAD".'
                    type: string
                  secretRef:
                    description: secretRef is the secret used to connect to the Git
                      source of truth.
                    properties:
                      name:
                        description: name represents the secret name.
                        type: string
                    type: object
              override:
                description: override allows to override the settings for a root reconciler.
                nullable: true
                properties:
                  gitSyncDepth:
                    description: gitSyncDepth allows one to override the number of git
                      commits to fetch. Must be no less than 0. Config Sync would do
                      a full clone if this field is 0, and a shallow clone if this field
                      is greater than 0. If this field is not provided, Config Sync
                      would configure it automatically.
                    format: int64
                    minimum: 0
                    type: integer
                  resources:
                    description: resources allow one to override the resource requirements
                      for the containers in a reconciler pod.
                    items:
                      description: ContainerResourcesSpec allows to override the resource
                        requirements for a container
                      properties:
                        containerName:
                          description: containerName specifies the name of a container
                            whose resource requirements will be overriden. Must be "reconciler"
                            or "git-sync".
                          pattern: ^(reconciler|git-sync|hydration-controller)$
                          type: string
                        cpuLimit:
                          anyOf:
                          - type: integer
                          - type: string
                          description: cpuLimit allows one to override the CPU limit
                            of a container
                          pattern: ^(\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))))?$
                          x-kubernetes-int-or-string: true
                        memoryLimit:
                          anyOf:
                          - type: integer
                          - type: string
                          description: memoryLimit allows one to override the memory
                            limit of a container
                          pattern: ^(\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))))?$
                          x-kubernetes-int-or-string: true
                      type: object
                    type: array
                type: object
              sourceFormat:
                description: "sourceFormat specifies how the repository is formatted.
                          See documentation for specifics of what these options do. \n Must
                          be one of hierarchy, unstructured. Optional. Set to hierarchy if not
                          specified. \n The validation of this is case-sensitive."
                pattern: ^(hierarchy|unstructured|)$
                type: string
          status:
            description: RootSyncStatus defines the observed state of RootSync
            type: object
            x-kubernetes-preserve-unknown-fields: true
    subresources:
      status: {}
---
# Custom Resource Definition for a declaring the types
# of resources Nomos should sync from the source of truth
# See pkg/api/configmanagement/v1alpha1/types.go
# for the CRD struct spec.
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: syncs.configmanagement.gke.io
  labels:
    configmanagement.gke.io/system: "true"
    configmanagement.gke.io/arch: "legacy"
spec:
  preserveUnknownFields: false
  group: configmanagement.gke.io
  scope: Cluster
  names:
    plural: syncs
    singular: sync
    kind: Sync
  versions:
    - name: v1
      served: true
      storage: true
      subresources:
        status: {}
      schema:
        openAPIV3Schema:
          type: object
          required:
          - spec
          properties:
            spec:
              # SyncSpec
              type: object
              x-kubernetes-preserve-unknown-fields: true
            status:
              # SyncStatus
              type: object
              x-kubernetes-preserve-unknown-fields: true
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: admission-webhook
  namespace: config-management-system
  labels:
    app: admission-webhook
    configmanagement.gke.io/system: "true"
    configmanagement.gke.io/arch: "csmr"
spec:
  minReadySeconds: 10
  selector:
    matchLabels:
      app: admission-webhook
  replicas: 2
  template:
    metadata:
      labels:
        app: admission-webhook
    spec:
      serviceAccountName: admission-webhook
      containers:
      - name: admission-webhook
        command:
        - /admission-webhook
        image: gcr.io/config-management-release/admission-webhook:v1.9.0-rc.5
        ports:
          - name: admission
            containerPort: 10250
            protocol: TCP
        resources:
          requests:
            cpu: 10m
            memory: 20Mi
          limits:
            cpu: 200m
            memory: 100Mi
        volumeMounts:
          - mountPath: /certs
            name: cert
            readOnly: true
      terminationGracePeriodSeconds: 10
      volumes:
      - name: cert
        secret:
          defaultMode: 420
          secretName: admission-webhook-cert
---
apiVersion: v1
kind: Service
metadata:
  name: admission-webhook
  namespace: config-management-system
  labels:
    monitored: "true"
    configmanagement.gke.io/system: "true"
    configmanagement.gke.io/arch: "csmr"
spec:
  selector:
    app: admission-webhook
  ports:
  - name: admission
    port: 443
    targetPort: admission
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: admission-webhook
  namespace: config-management-system
  labels:
    configmanagement.gke.io/system: "true"
    configmanagement.gke.io/arch: "csmr"
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: configsync.gke.io:admission-webhook
  labels:
    configmanagement.gke.io/system: "true"
    configmanagement.gke.io/arch: "csmr"
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  # The admission webhook must be cluster-admin in order to deny requests to any
  # object on the cluster.
  name: cluster-admin
subjects:
- kind: ServiceAccount
  name: admission-webhook
  namespace: config-management-system
---
apiVersion: v1
kind: Secret
metadata:
  name: admission-webhook-cert
  namespace: config-management-system
  labels:
    configmanagement.gke.io/system: "true"
    configmanagement.gke.io/arch: "csmr"
---
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  name: admission-webhook.configsync.gke.io
  labels:
    configmanagement.gke.io/system: "true"
    configmanagement.gke.io/arch: "csmr"
---
# TODO(b/158594746): Use one git-importer deployment instead of three.
apiVersion: v1
kind: Service
metadata:
  name: git-importer
  namespace: config-management-system
  labels:
    monitored: "true"
    configmanagement.gke.io/system: "true"
    configmanagement.gke.io/arch: "legacy"
spec:
  selector:
    app: git-importer
  ports:
    - name: metrics
      port: 8675
      targetPort: metrics-port
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: git-importer
  namespace: config-management-system
  labels:
    app: git-importer
    configmanagement.gke.io/system: "true"
    configmanagement.gke.io/arch: "legacy"
spec:
  minReadySeconds: 10
  replicas: 1
  strategy:
    type: Recreate
  selector:
    matchLabels:
      app: git-importer
  template:
    metadata:
      labels:
        app: git-importer
    spec:
      serviceAccountName: importer
      containers:
      - name: importer
        image: gcr.io/config-management-release/nomos:v1.9.0-rc.5
        command: ["git-importer"]
        args:
        - "--v=0"
        - "--git-dir=/repo/root/rev"
        ports:
          - containerPort: 8675
            name: metrics-port
        volumeMounts:
          - name: repo
            mountPath: /repo
            readOnly: true
        envFrom:
          - configMapRef:
              name: importer
          - configMapRef:
              name: cluster-name
              optional: true  # If cluster naming is not used, this config map will be missing.
          - configMapRef:
              name: source-format
              optional: true
        resources:
          requests:
            cpu: "150m"
            memory: "100Mi"
          limits:
            cpu: "1"
            memory: "200Mi"
      - name: fs-watcher
        image: gcr.io/config-management-release/nomos:v1.9.0-rc.5
        command: ["git-importer"]
        args:
        - "--v=0"
        - "--watch-directory=/repo"
        volumeMounts:
          - name: repo
            mountPath: /repo
            readOnly: true
        envFrom:
          - configMapRef:
              name: importer-fs-watcher # allow user override for WATCH_PERIOD
              optional: true
        resources:
          requests:
            cpu: "150m"
            memory: "100Mi"
          limits:
            cpu: "1"
            memory: "200Mi"
      - name: git-sync
        image: gcr.io/config-management-release/git-sync:v3.3.3-gke.0__linux_amd64
        # Do not put "rev-" in the root arg or you will break our parsing of commit hashes. See
        # pkg/policyimporter/git/git.go to see where we depend on that magic string from git-sync.
        args: ["--root=/repo/root", "--dest=rev", "--max-sync-failures=30", "--error-file=error.json", "--v=5"]
        volumeMounts:
        - name: repo
          mountPath: /repo
        - name: git-creds
          mountPath: /etc/git-secret
          readOnly: true
        securityContext:
          runAsUser: 65533 # this is a non-root user declared by git-sync
        envFrom:
          - configMapRef:
              name: git-sync
        resources:
          requests:
            cpu: "150m"
            memory: "100Mi"
          limits:
            cpu: "1"
            memory: "200Mi"
      volumes:
      - name: repo
      - name: git-creds
        secret:
          secretName: git-creds
          defaultMode: 288 # 0440; we need group read so that fsGroup below gives access
      securityContext:
        fsGroup: 65533 # to make SSH key readable
---
apiVersion: v1
kind: Service
metadata:
  name: monitor
  namespace: config-management-system
  labels:
    monitored: "true"
    configmanagement.gke.io/system: "true"
    configmanagement.gke.io/arch: "legacy"
spec:
  selector:
    app: monitor
  ports:
  - name: metrics
    port: 8675
    targetPort: metrics-port
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: monitor
  namespace: config-management-system
  labels:
    app: monitor
    configmanagement.gke.io/system: "true"
    configmanagement.gke.io/arch: "legacy"
spec:
  minReadySeconds: 1
  replicas: 1
  strategy:
    type: Recreate
  selector:
    matchLabels:
      app: monitor
  template:
    metadata:
      labels:
        app: monitor
    spec:
      serviceAccountName: monitor
      containers:
      - name: monitor
        image: gcr.io/config-management-release/nomos:v1.9.0-rc.5
        command: ["monitor"]
        args:
        - "--v=0"
        ports:
        - containerPort: 8675
          name: metrics-port
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: otel-collector
  namespace: config-management-monitoring
  labels:
    app: opentelemetry
    component: otel-collector
    configmanagement.gke.io/system: "true"
    configmanagement.gke.io/arch: "csmr"
data:
  otel-collector-config.yaml: |
    receivers:
      opencensus:
    exporters:
      prometheus:
        endpoint: :8675
        namespace: config_sync
    processors:
      batch:
    extensions:
      health_check:
    service:
      extensions: [health_check]
      pipelines:
        metrics:
          receivers: [opencensus]
          processors: [batch]
          exporters: [prometheus]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: configmanagement.gke.io:otel-collector-psp
  namespace: config-management-monitoring
  labels:
    component: otel-collector
    configmanagement.gke.io/system: "true"
    configmanagement.gke.io/arch: "csmr"
rules:
- apiGroups:
  - policy
  resources:
  - podsecuritypolicies
  resourceNames:
  - acm-psp
  verbs:
  - use
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: configmanagement.gke.io:otel-collector-psp
  namespace: config-management-monitoring
  labels:
    component: otel-collector
    configmanagement.gke.io/system: "true"
    configmanagement.gke.io/arch: "csmr"
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: configmanagement.gke.io:otel-collector-psp
subjects:
- kind: ServiceAccount
  name: default
  namespace: config-management-monitoring
---
apiVersion: v1
kind: Service
metadata:
  name: otel-collector
  namespace: config-management-monitoring
  labels:
    monitored: "true"
    configmanagement.gke.io/system: "true"
    configmanagement.gke.io/arch: "csmr"
spec:
  selector:
    app: opentelemetry
    component: otel-collector
  ports:
  - name: opencensus # Default endpoint for OpenCensus receiver.
    port: 55678
    protocol: TCP
    targetPort: 55678
  - name: metrics-default # Default endpoint for querying metrics.
    port: 8888
  - name: metrics # Prometheus exporter metrics.
    port: 8675
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: otel-collector
  namespace: config-management-monitoring
  labels:
    app: opentelemetry
    component: otel-collector
    configmanagement.gke.io/system: "true"
    configmanagement.gke.io/arch: "csmr"
spec:
  selector:
    matchLabels:
      app: opentelemetry
      component: otel-collector
  minReadySeconds: 5
  progressDeadlineSeconds: 120
  replicas: 1
  template:
    metadata:
      labels:
        app: opentelemetry
        component: otel-collector
    spec:
      containers:
      - name: otel-collector
        image: gcr.io/config-management-release/otelcontribcol:v0.22.0
        command:
        - /otelcontribcol
        args:
        - "--config=/conf/otel-collector-config.yaml"
        resources:
          limits:
            cpu: 1
            memory: 2Gi
          requests:
            cpu: 200m
            memory: 400Mi
        ports:
        - containerPort: 55678 # Default endpoint for OpenCensus receiver.
        - containerPort: 8888  # Default endpoint for querying metrics.
        - containerPort: 8675  # Prometheus exporter metrics.
        volumeMounts:
        - name: otel-collector-config-vol
          mountPath: /conf
        livenessProbe:
          httpGet:
            path: /
            port: 13133 # Health Check extension default port.
        readinessProbe:
          httpGet:
            path: /
            port: 13133 # Health Check extension default port.
      volumes:
      - name: otel-collector-config-vol
        projected:
          sources:
          - configMap:
              name: otel-collector
          - configMap:
              name: otel-collector-stackdriver
              optional: true
          - configMap:
              name: otel-collector-custom
              optional: true
      securityContext:
        fsGroup: 2000
        runAsNonRoot: true
        runAsUser: 1000
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: reconciler-manager-cm
  namespace: config-management-system
  labels:
    configmanagement.gke.io/system: "true"
    configmanagement.gke.io/arch: "csmr"
data:
  deployment.yaml: |
   apiVersion: apps/v1
   kind: Deployment
   metadata:
     name: # this field will be assigned dynamically by the reconciler-manager
     namespace: config-management-system
     labels:
       app: reconciler
       configmanagement.gke.io/system: "true"
       configmanagement.gke.io/arch: "csmr"
   spec:
     minReadySeconds: 10
     replicas: 1
     strategy:
       type: Recreate
     selector:
       matchLabels:
         app: reconciler
     template:
       metadata:
         labels:
           app: reconciler
       spec:
         serviceAccountName: # this field will be assigned dynamically by the reconciler-manager
         containers:
         - name: hydration-controller
           image: gcr.io/config-management-release/hydration-controller:v1.9.0-rc.5
           command:
           - /hydration-controller
           args:
           - "--v=0"
           - "--repo-root=/repo"
           - "--source-root=source"
           - "--hydrated-root=hydrated"
           - "--source-link=rev"
           - "--hydrated-link=rev"
           volumeMounts:
             - name: repo
               mountPath: /repo
           securityContext:
             runAsUser: 65533
           env:
             - name: RECONCILER_NAME
               valueFrom:
                 fieldRef:
                   fieldPath: metadata.name
           envFrom:
             - configMapRef:
                 name: hydration-controller
           resources:
             limits:
               cpu: "1"
               memory: "300Mi"
             requests:
               cpu: "10m"
               memory: "100Mi"
         - name: reconciler
           image: gcr.io/config-management-release/reconciler:v1.9.0-rc.5
           command:
           - /reconciler
           args:
           - "--v=0"
           - "--repo-root=/repo"
           - "--git-dir=/repo/source/rev"
           - "--hydrated-root=/repo/hydrated"
           - "--hydrated-link=rev"
           volumeMounts:
             - name: repo
               mountPath: /repo
               readOnly: true
           env:
             - name: RECONCILER_NAME
               valueFrom:
                 fieldRef:
                   fieldPath: metadata.name
           envFrom:
             - configMapRef:
                 name: reconciler
             - configMapRef:
                 name: source-format
                 optional: true
           resources:
             limits:
               cpu: "1"
               memory: "300Mi"
             requests:
               cpu: "50m"
               memory: "100Mi"
         - name: git-sync
           image: gcr.io/config-management-release/git-sync:v3.3.3-gke.0__linux_amd64
           args: ["--root=/repo/source", "--dest=rev", "--max-sync-failures=30", "--error-file=error.json", "--v=5"]
           volumeMounts:
           - name: repo
             mountPath: /repo
           - name: git-creds
             mountPath: /etc/git-secret
             readOnly: true
           securityContext:
             runAsUser: 65533
           envFrom:
           - configMapRef:
               name: git-sync
           resources:
             limits:
               cpu: "1"
               memory: "200Mi"
             requests:
               cpu: "10m"
               memory: "10Mi"
         - name: otel-agent
           image: gcr.io/config-management-release/otelcol:v0.22.0
           command:
           - /otelcol
           args:
           - "--config=/conf/otel-agent-config.yaml"
           resources:
             limits:
               cpu: 500m
               memory: 500Mi
             requests:
               cpu: 10m
               memory: 100Mi
           ports:
           - containerPort: 55678 # Default OpenCensus receiver port.
           - containerPort: 8888  # Metrics.
           volumeMounts:
           - name: otel-agent-config-vol
             mountPath: /conf
           livenessProbe:
             httpGet:
               path: /
               port: 13133 # Health Check extension default port.
           readinessProbe:
             httpGet:
               path: /
               port: 13133 # Health Check extension default port.
         volumes:
         - name: repo
         - name: git-creds
           secret:
             secretName: git-creds
             defaultMode: 288
         - name: otel-agent-config-vol
           configMap:
             name: otel-agent
         securityContext:
           fsGroup: 65533
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: reconciler-manager
  namespace: config-management-system
  labels:
    app: reconciler-manager
    configmanagement.gke.io/system: "true"
    configmanagement.gke.io/arch: "csmr"
spec:
  minReadySeconds: 10
  selector:
    matchLabels:
      app: reconciler-manager
  replicas: 1
  template:
    metadata:
      labels:
        app: reconciler-manager
    spec:
      serviceAccountName: reconciler-manager
      containers:
      - command:
        - /reconciler-manager
        args:
        - --enable-leader-election
        image: gcr.io/config-management-release/reconciler-manager:v1.9.0-rc.5
        name: reconciler-manager
        resources:
          requests:
            cpu: 10m
            memory: 20Mi
          limits:
            cpu: 200m
            memory: 100Mi
        volumeMounts:
        - name: configs
          mountPath: /deployment.yaml
          subPath: deployment.yaml
        envFrom:
          - configMapRef:
              name: reconciler-manager
              optional: true  # Currently nothing mandatory in the ConfigMap
      - name: otel-agent
        image: gcr.io/config-management-release/otelcol:v0.22.0
        command:
        - /otelcol
        args:
        - "--config=/conf/otel-agent-config.yaml"
        resources:
          limits:
            cpu: 500m
            memory: 500Mi
          requests:
            cpu: 10m
            memory: 100Mi
        ports:
        - containerPort: 55678 # Default OpenCensus receiver port.
        - containerPort: 8888  # Metrics.
        volumeMounts:
        - name: otel-agent-config-vol
          mountPath: /conf
        livenessProbe:
          httpGet:
            path: /
            port: 13133 # Health Check extension default port.
        readinessProbe:
          httpGet:
            path: /
            port: 13133 # Health Check extension default port.
      terminationGracePeriodSeconds: 10
      volumes:
      - name: configs
        configMap:
          name: reconciler-manager-cm
      - name: otel-agent-config-vol
        configMap:
          name: otel-agent
---

# ----- gatekeeper_manifest.yaml -----
apiVersion: v1
kind: Namespace
metadata:
  labels:
    admission.gatekeeper.sh/ignore: no-self-managing
    control-plane: controller-manager
    gatekeeper.sh/system: "yes"
    policycontroller.configmanagement.gke.io: "true"
  name: gatekeeper-system
---
apiVersion: v1
kind: ResourceQuota
metadata:
  labels:
    gatekeeper.sh/system: "yes"
    policycontroller.configmanagement.gke.io: "true"
  name: gatekeeper-critical-pods
  namespace: gatekeeper-system
spec:
  hard:
    pods: 100
  scopeSelector:
    matchExpressions:
    - operator: In
      scopeName: PriorityClass
      values:
      - system-cluster-critical
---
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  annotations:
    controller-gen.kubebuilder.io/version: v0.5.0
  creationTimestamp: null
  labels:
    policycontroller.configmanagement.gke.io: "true"
    policycontroller.configmanagement.gke.io/mutation: "true"
  name: assign.mutations.gatekeeper.sh
spec:
  group: mutations.gatekeeper.sh
  names:
    kind: Assign
    listKind: AssignList
    plural: assign
    singular: assign
  scope: Cluster
  versions:
  - name: v1alpha1
    schema:
      openAPIV3Schema:
        description: Assign is the Schema for the assign API
        properties:
          apiVersion:
            description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
            type: string
          kind:
            description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
            type: string
          metadata:
            type: object
          spec:
            description: AssignSpec defines the desired state of Assign
            properties:
              applyTo:
                description: 'INSERT ADDITIONAL SPEC FIELDS - desired state of cluster Important: Run "make" to regenerate code after modifying this file'
                items:
                  description: ApplyTo determines what GVKs items the mutation should apply to. Globs are not allowed.
                  properties:
                    groups:
                      items:
                        type: string
                      type: array
                    kinds:
                      items:
                        type: string
                      type: array
                    versions:
                      items:
                        type: string
                      type: array
                  type: object
                type: array
              location:
                type: string
              match:
                description: Match selects objects to apply mutations to.
                properties:
                  excludedNamespaces:
                    items:
                      type: string
                    type: array
                  kinds:
                    items:
                      description: Kinds accepts a list of objects with apiGroups and kinds fields that list the groups/kinds of objects to which the mutation will apply. If multiple groups/kinds objects are specified, only one match is needed for the resource to be in scope.
                      properties:
                        apiGroups:
                          description: APIGroups is the API groups the resources belong to. '*' is all groups. If '*' is present, the length of the slice must be one. Required.
                          items:
                            type: string
                          type: array
                        kinds:
                          items:
                            type: string
                          type: array
                      type: object
                    type: array
                  labelSelector:
                    description: A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
                    properties:
                      matchExpressions:
                        description: matchExpressions is a list of label selector requirements. The requirements are ANDed.
                        items:
                          description: A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
                          properties:
                            key:
                              description: key is the label key that the selector applies to.
                              type: string
                            operator:
                              description: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
                              type: string
                            values:
                              description: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
                              items:
                                type: string
                              type: array
                          required:
                          - key
                          - operator
                          type: object
                        type: array
                      matchLabels:
                        additionalProperties:
                          type: string
                        description: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
                        type: object
                    type: object
                  namespaceSelector:
                    description: A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
                    properties:
                      matchExpressions:
                        description: matchExpressions is a list of label selector requirements. The requirements are ANDed.
                        items:
                          description: A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
                          properties:
                            key:
                              description: key is the label key that the selector applies to.
                              type: string
                            operator:
                              description: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
                              type: string
                            values:
                              description: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
                              items:
                                type: string
                              type: array
                          required:
                          - key
                          - operator
                          type: object
                        type: array
                      matchLabels:
                        additionalProperties:
                          type: string
                        description: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
                        type: object
                    type: object
                  namespaces:
                    items:
                      type: string
                    type: array
                  scope:
                    description: ResourceScope is an enum defining the different scopes available to a custom resource
                    type: string
                type: object
              parameters:
                properties:
                  assign:
                    description: Assign.value holds the value to be assigned
                    type: object
                    x-kubernetes-preserve-unknown-fields: true
                  assignIf:
                    description: once https://github.com/kubernetes-sigs/controller-tools/pull/528 is merged, we can use an actual object
                    type: object
                  pathTests:
                    items:
                      description: "PathTest allows the user to customize how the mutation works if parent paths are missing. It traverses the list in order. All sub paths are tested against the provided condition, if the test fails, the mutation is not applied. All `subPath` entries must be a prefix of `location`. Any glob characters will take on the same value as was used to expand the matching glob in `location`. \n Available Tests: * MustExist    - the path must exist or do not mutate * MustNotExist - the path must not exist or do not mutate"
                      properties:
                        condition:
                          description: Condition describes whether the path either MustExist or MustNotExist in the original object
                          enum:
                          - MustExist
                          - MustNotExist
                          type: string
                        subPath:
                          type: string
                      type: object
                    type: array
                type: object
            type: object
          status:
            description: AssignStatus defines the observed state of Assign
            properties:
              byPod:
                items:
                  description: MutatorPodStatusStatus defines the observed state of MutatorPodStatus
                  properties:
                    enforced:
                      type: boolean
                    errors:
                      items:
                        description: MutatorError represents a single error caught while adding a mutator to a system
                        properties:
                          message:
                            type: string
                        required:
                        - message
                        type: object
                      type: array
                    id:
                      type: string
                    mutatorUID:
                      description: Storing the mutator UID allows us to detect drift, such as when a mutator has been recreated after its CRD was deleted out from under it, interrupting the watch
                      type: string
                    observedGeneration:
                      format: int64
                      type: integer
                    operations:
                      items:
                        type: string
                      type: array
                  type: object
                type: array
            type: object
        type: object
    served: true
    storage: true
    subresources:
      status: {}
status:
  acceptedNames:
    kind: ""
    plural: ""
  conditions: []
  storedVersions: []
---
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  annotations:
    controller-gen.kubebuilder.io/version: v0.5.0
  creationTimestamp: null
  labels:
    policycontroller.configmanagement.gke.io: "true"
    policycontroller.configmanagement.gke.io/mutation: "true"
  name: assignmetadata.mutations.gatekeeper.sh
spec:
  group: mutations.gatekeeper.sh
  names:
    kind: AssignMetadata
    listKind: AssignMetadataList
    plural: assignmetadata
    singular: assignmetadata
  scope: Cluster
  versions:
  - name: v1alpha1
    schema:
      openAPIV3Schema:
        description: AssignMetadata is the Schema for the assignmetadata API
        properties:
          apiVersion:
            description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
            type: string
          kind:
            description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
            type: string
          metadata:
            type: object
          spec:
            description: AssignMetadataSpec defines the desired state of AssignMetadata
            properties:
              location:
                type: string
              match:
                description: Match selects objects to apply mutations to.
                properties:
                  excludedNamespaces:
                    items:
                      type: string
                    type: array
                  kinds:
                    items:
                      description: Kinds accepts a list of objects with apiGroups and kinds fields that list the groups/kinds of objects to which the mutation will apply. If multiple groups/kinds objects are specified, only one match is needed for the resource to be in scope.
                      properties:
                        apiGroups:
                          description: APIGroups is the API groups the resources belong to. '*' is all groups. If '*' is present, the length of the slice must be one. Required.
                          items:
                            type: string
                          type: array
                        kinds:
                          items:
                            type: string
                          type: array
                      type: object
                    type: array
                  labelSelector:
                    description: A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
                    properties:
                      matchExpressions:
                        description: matchExpressions is a list of label selector requirements. The requirements are ANDed.
                        items:
                          description: A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
                          properties:
                            key:
                              description: key is the label key that the selector applies to.
                              type: string
                            operator:
                              description: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
                              type: string
                            values:
                              description: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
                              items:
                                type: string
                              type: array
                          required:
                          - key
                          - operator
                          type: object
                        type: array
                      matchLabels:
                        additionalProperties:
                          type: string
                        description: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
                        type: object
                    type: object
                  namespaceSelector:
                    description: A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
                    properties:
                      matchExpressions:
                        description: matchExpressions is a list of label selector requirements. The requirements are ANDed.
                        items:
                          description: A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
                          properties:
                            key:
                              description: key is the label key that the selector applies to.
                              type: string
                            operator:
                              description: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
                              type: string
                            values:
                              description: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
                              items:
                                type: string
                              type: array
                          required:
                          - key
                          - operator
                          type: object
                        type: array
                      matchLabels:
                        additionalProperties:
                          type: string
                        description: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
                        type: object
                    type: object
                  namespaces:
                    items:
                      type: string
                    type: array
                  scope:
                    description: ResourceScope is an enum defining the different scopes available to a custom resource
                    type: string
                type: object
              parameters:
                properties:
                  assign:
                    description: Assign.value holds the value to be assigned
                    type: object
                    x-kubernetes-preserve-unknown-fields: true
                type: object
            type: object
          status:
            description: AssignMetadataStatus defines the observed state of AssignMetadata
            properties:
              byPod:
                description: 'INSERT ADDITIONAL STATUS FIELD - define observed state of cluster Important: Run "make" to regenerate code after modifying this file'
                items:
                  description: MutatorPodStatusStatus defines the observed state of MutatorPodStatus
                  properties:
                    enforced:
                      type: boolean
                    errors:
                      items:
                        description: MutatorError represents a single error caught while adding a mutator to a system
                        properties:
                          message:
                            type: string
                        required:
                        - message
                        type: object
                      type: array
                    id:
                      type: string
                    mutatorUID:
                      description: Storing the mutator UID allows us to detect drift, such as when a mutator has been recreated after its CRD was deleted out from under it, interrupting the watch
                      type: string
                    observedGeneration:
                      format: int64
                      type: integer
                    operations:
                      items:
                        type: string
                      type: array
                  type: object
                type: array
            type: object
        type: object
    served: true
    storage: true
    subresources:
      status: {}
status:
  acceptedNames:
    kind: ""
    plural: ""
  conditions: []
  storedVersions: []
---
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  annotations:
    controller-gen.kubebuilder.io/version: v0.5.0
  labels:
    gatekeeper.sh/system: "yes"
    policycontroller.configmanagement.gke.io: "true"
  name: configs.config.gatekeeper.sh
spec:
  group: config.gatekeeper.sh
  names:
    kind: Config
    listKind: ConfigList
    plural: configs
    singular: config
  preserveUnknownFields: false
  scope: Namespaced
  versions:
  - name: v1alpha1
    schema:
      openAPIV3Schema:
        description: Config is the Schema for the configs API.
        properties:
          apiVersion:
            description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
            type: string
          kind:
            description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
            type: string
          metadata:
            type: object
          spec:
            description: ConfigSpec defines the desired state of Config.
            properties:
              match:
                description: Configuration for namespace exclusion
                items:
                  properties:
                    excludedNamespaces:
                      items:
                        description: 'A string that supports globbing at its end.  Ex: "kube-*" will match "kube-system" or "kube-public".  The asterisk is required for wildcard matching.'
                        pattern: ^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\*|-\*)?$
                        type: string
                      type: array
                    processes:
                      items:
                        type: string
                      type: array
                  type: object
                type: array
              readiness:
                description: Configuration for readiness tracker
                properties:
                  statsEnabled:
                    type: boolean
                type: object
              sync:
                description: Configuration for syncing k8s objects
                properties:
                  syncOnly:
                    description: If non-empty, only entries on this list will be replicated into OPA
                    items:
                      properties:
                        group:
                          type: string
                        kind:
                          type: string
                        version:
                          type: string
                      type: object
                    type: array
                type: object
              validation:
                description: Configuration for validation
                properties:
                  traces:
                    description: List of requests to trace. Both "user" and "kinds" must be specified
                    items:
                      properties:
                        dump:
                          description: Also dump the state of OPA with the trace. Set to `All` to dump everything.
                          type: string
                        kind:
                          description: Only trace requests of the following GroupVersionKind
                          properties:
                            group:
                              type: string
                            kind:
                              type: string
                            version:
                              type: string
                          type: object
                        user:
                          description: Only trace requests from the specified user
                          type: string
                      type: object
                    type: array
                type: object
            type: object
          status:
            description: ConfigStatus defines the observed state of Config.
            type: object
        type: object
    served: true
    storage: true
status:
  acceptedNames:
    kind: ""
    plural: ""
  conditions: []
  storedVersions: []
---
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  annotations:
    controller-gen.kubebuilder.io/version: v0.5.0
  labels:
    gatekeeper.sh/system: "yes"
    policycontroller.configmanagement.gke.io: "true"
  name: constraintpodstatuses.status.gatekeeper.sh
spec:
  group: status.gatekeeper.sh
  names:
    kind: ConstraintPodStatus
    listKind: ConstraintPodStatusList
    plural: constraintpodstatuses
    singular: constraintpodstatus
  preserveUnknownFields: false
  scope: Namespaced
  versions:
  - name: v1beta1
    schema:
      openAPIV3Schema:
        description: ConstraintPodStatus is the Schema for the constraintpodstatuses API.
        properties:
          apiVersion:
            description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
            type: string
          kind:
            description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
            type: string
          metadata:
            type: object
          status:
            description: ConstraintPodStatusStatus defines the observed state of ConstraintPodStatus.
            properties:
              constraintUID:
                description: Storing the constraint UID allows us to detect drift, such as when a constraint has been recreated after its CRD was deleted out from under it, interrupting the watch
                type: string
              enforced:
                type: boolean
              errors:
                items:
                  description: Error represents a single error caught while adding a constraint to OPA.
                  properties:
                    code:
                      type: string
                    location:
                      type: string
                    message:
                      type: string
                  required:
                  - code
                  - message
                  type: object
                type: array
              id:
                type: string
              observedGeneration:
                format: int64
                type: integer
              operations:
                items:
                  type: string
                type: array
            type: object
        type: object
    served: true
    storage: true
status:
  acceptedNames:
    kind: ""
    plural: ""
  conditions: []
  storedVersions: []
---
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  annotations:
    controller-gen.kubebuilder.io/version: v0.5.0
  labels:
    gatekeeper.sh/system: "yes"
    policycontroller.configmanagement.gke.io: "true"
  name: constrainttemplatepodstatuses.status.gatekeeper.sh
spec:
  group: status.gatekeeper.sh
  names:
    kind: ConstraintTemplatePodStatus
    listKind: ConstraintTemplatePodStatusList
    plural: constrainttemplatepodstatuses
    singular: constrainttemplatepodstatus
  preserveUnknownFields: false
  scope: Namespaced
  versions:
  - name: v1beta1
    schema:
      openAPIV3Schema:
        description: ConstraintTemplatePodStatus is the Schema for the constrainttemplatepodstatuses API.
        properties:
          apiVersion:
            description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
            type: string
          kind:
            description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
            type: string
          metadata:
            type: object
          status:
            description: ConstraintTemplatePodStatusStatus defines the observed state of ConstraintTemplatePodStatus.
            properties:
              errors:
                items:
                  description: CreateCRDError represents a single error caught during parsing, compiling, etc.
                  properties:
                    code:
                      type: string
                    location:
                      type: string
                    message:
                      type: string
                  required:
                  - code
                  - message
                  type: object
                type: array
              id:
                description: 'Important: Run "make" to regenerate code after modifying this file'
                type: string
              observedGeneration:
                format: int64
                type: integer
              operations:
                items:
                  type: string
                type: array
              templateUID:
                description: UID is a type that holds unique ID values, including UUIDs.  Because we don't ONLY use UUIDs, this is an alias to string.  Being a type captures intent and helps make sure that UIDs and names do not get conflated.
                type: string
            type: object
        type: object
    served: true
    storage: true
status:
  acceptedNames:
    kind: ""
    plural: ""
  conditions: []
  storedVersions: []
---
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  annotations:
    controller-gen.kubebuilder.io/version: v0.5.0
  labels:
    gatekeeper.sh/system: "yes"
    policycontroller.configmanagement.gke.io: "true"
  name: constrainttemplates.templates.gatekeeper.sh
spec:
  group: templates.gatekeeper.sh
  names:
    kind: ConstraintTemplate
    listKind: ConstraintTemplateList
    plural: constrainttemplates
    singular: constrainttemplate
  preserveUnknownFields: false
  scope: Cluster
  versions:
  - name: v1
    schema:
      openAPIV3Schema:
        description: ConstraintTemplate is the Schema for the constrainttemplates API
        properties:
          apiVersion:
            description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
            type: string
          kind:
            description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
            type: string
          metadata:
            type: object
          spec:
            description: ConstraintTemplateSpec defines the desired state of ConstraintTemplate
            properties:
              crd:
                properties:
                  spec:
                    properties:
                      names:
                        properties:
                          kind:
                            type: string
                          shortNames:
                            items:
                              type: string
                            type: array
                        type: object
                      validation:
                        default:
                          legacySchema: false
                        properties:
                          legacySchema:
                            default: false
                            type: boolean
                          openAPIV3Schema:
                            type: object
                            x-kubernetes-preserve-unknown-fields: true
                        type: object
                    type: object
                type: object
              targets:
                items:
                  properties:
                    libs:
                      items:
                        type: string
                      type: array
                    rego:
                      type: string
                    target:
                      type: string
                  type: object
                type: array
            type: object
          status:
            description: ConstraintTemplateStatus defines the observed state of ConstraintTemplate
            properties:
              byPod:
                items:
                  description: ByPodStatus defines the observed state of ConstraintTemplate as seen by an individual controller
                  properties:
                    errors:
                      items:
                        description: CreateCRDError represents a single error caught during parsing, compiling, etc.
                        properties:
                          code:
                            type: string
                          location:
                            type: string
                          message:
                            type: string
                        required:
                        - code
                        - message
                        type: object
                      type: array
                    id:
                      description: a unique identifier for the pod that wrote the status
                      type: string
                    observedGeneration:
                      format: int64
                      type: integer
                  type: object
                  x-kubernetes-preserve-unknown-fields: true
                type: array
              created:
                type: boolean
            type: object
        type: object
    served: true
    storage: true
    subresources:
      status: {}
  - name: v1alpha1
    schema:
      openAPIV3Schema:
        description: ConstraintTemplate is the Schema for the constrainttemplates API
        properties:
          apiVersion:
            description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
            type: string
          kind:
            description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
            type: string
          metadata:
            type: object
          spec:
            description: ConstraintTemplateSpec defines the desired state of ConstraintTemplate
            properties:
              crd:
                properties:
                  spec:
                    properties:
                      names:
                        properties:
                          kind:
                            type: string
                          shortNames:
                            items:
                              type: string
                            type: array
                        type: object
                      validation:
                        default:
                          legacySchema: true
                        properties:
                          legacySchema:
                            default: true
                            type: boolean
                          openAPIV3Schema:
                            type: object
                            x-kubernetes-preserve-unknown-fields: true
                        type: object
                    type: object
                type: object
              targets:
                items:
                  properties:
                    libs:
                      items:
                        type: string
                      type: array
                    rego:
                      type: string
                    target:
                      type: string
                  type: object
                type: array
            type: object
          status:
            description: ConstraintTemplateStatus defines the observed state of ConstraintTemplate
            properties:
              byPod:
                items:
                  description: ByPodStatus defines the observed state of ConstraintTemplate as seen by an individual controller
                  properties:
                    errors:
                      items:
                        description: CreateCRDError represents a single error caught during parsing, compiling, etc.
                        properties:
                          code:
                            type: string
                          location:
                            type: string
                          message:
                            type: string
                        required:
                        - code
                        - message
                        type: object
                      type: array
                    id:
                      description: a unique identifier for the pod that wrote the status
                      type: string
                    observedGeneration:
                      format: int64
                      type: integer
                  type: object
                  x-kubernetes-preserve-unknown-fields: true
                type: array
              created:
                type: boolean
            type: object
        type: object
    served: true
    storage: false
    subresources:
      status: {}
  - name: v1beta1
    schema:
      openAPIV3Schema:
        description: ConstraintTemplate is the Schema for the constrainttemplates API
        properties:
          apiVersion:
            description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
            type: string
          kind:
            description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
            type: string
          metadata:
            type: object
          spec:
            description: ConstraintTemplateSpec defines the desired state of ConstraintTemplate
            properties:
              crd:
                properties:
                  spec:
                    properties:
                      names:
                        properties:
                          kind:
                            type: string
                          shortNames:
                            items:
                              type: string
                            type: array
                        type: object
                      validation:
                        default:
                          legacySchema: true
                        properties:
                          legacySchema:
                            default: true
                            type: boolean
                          openAPIV3Schema:
                            type: object
                            x-kubernetes-preserve-unknown-fields: true
                        type: object
                    type: object
                type: object
              targets:
                items:
                  properties:
                    libs:
                      items:
                        type: string
                      type: array
                    rego:
                      type: string
                    target:
                      type: string
                  type: object
                type: array
            type: object
          status:
            description: ConstraintTemplateStatus defines the observed state of ConstraintTemplate
            properties:
              byPod:
                items:
                  description: ByPodStatus defines the observed state of ConstraintTemplate as seen by an individual controller
                  properties:
                    errors:
                      items:
                        description: CreateCRDError represents a single error caught during parsing, compiling, etc.
                        properties:
                          code:
                            type: string
                          location:
                            type: string
                          message:
                            type: string
                        required:
                        - code
                        - message
                        type: object
                      type: array
                    id:
                      description: a unique identifier for the pod that wrote the status
                      type: string
                    observedGeneration:
                      format: int64
                      type: integer
                  type: object
                  x-kubernetes-preserve-unknown-fields: true
                type: array
              created:
                type: boolean
            type: object
        type: object
    served: true
    storage: false
    subresources:
      status: {}
status:
  acceptedNames:
    kind: ""
    plural: ""
  conditions: []
  storedVersions: []
---
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  annotations:
    controller-gen.kubebuilder.io/version: v0.5.0
  creationTimestamp: null
  labels:
    policycontroller.configmanagement.gke.io: "true"
    policycontroller.configmanagement.gke.io/mutation: "true"
  name: mutatorpodstatuses.status.gatekeeper.sh
spec:
  group: status.gatekeeper.sh
  names:
    kind: MutatorPodStatus
    listKind: MutatorPodStatusList
    plural: mutatorpodstatuses
    singular: mutatorpodstatus
  scope: Namespaced
  versions:
  - name: v1beta1
    schema:
      openAPIV3Schema:
        description: MutatorPodStatus is the Schema for the mutationpodstatuses API
        properties:
          apiVersion:
            description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
            type: string
          kind:
            description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
            type: string
          metadata:
            type: object
          status:
            description: MutatorPodStatusStatus defines the observed state of MutatorPodStatus
            properties:
              enforced:
                type: boolean
              errors:
                items:
                  description: MutatorError represents a single error caught while adding a mutator to a system
                  properties:
                    message:
                      type: string
                  required:
                  - message
                  type: object
                type: array
              id:
                type: string
              mutatorUID:
                description: Storing the mutator UID allows us to detect drift, such as when a mutator has been recreated after its CRD was deleted out from under it, interrupting the watch
                type: string
              observedGeneration:
                format: int64
                type: integer
              operations:
                items:
                  type: string
                type: array
            type: object
        type: object
    served: true
    storage: true
status:
  acceptedNames:
    kind: ""
    plural: ""
  conditions: []
  storedVersions: []
---
apiVersion: v1
kind: ServiceAccount
metadata:
  labels:
    gatekeeper.sh/system: "yes"
    policycontroller.configmanagement.gke.io: "true"
  name: gatekeeper-admin
  namespace: gatekeeper-system
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  creationTimestamp: null
  labels:
    gatekeeper.sh/system: "yes"
    policycontroller.configmanagement.gke.io: "true"
  name: gatekeeper-manager-role
  namespace: gatekeeper-system
rules:
- apiGroups:
  - ""
  resources:
  - events
  verbs:
  - create
  - patch
- apiGroups:
  - ""
  resources:
  - secrets
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  creationTimestamp: null
  labels:
    gatekeeper.sh/system: "yes"
    policycontroller.configmanagement.gke.io: "true"
  name: gatekeeper-manager-role
rules:
- apiGroups:
  - '*'
  resources:
  - '*'
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - apiextensions.k8s.io
  resources:
  - customresourcedefinitions
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - config.gatekeeper.sh
  resources:
  - configs
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - config.gatekeeper.sh
  resources:
  - configs/status
  verbs:
  - get
  - patch
  - update
- apiGroups:
  - constraints.gatekeeper.sh
  resources:
  - '*'
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - mutations.gatekeeper.sh
  resources:
  - '*'
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - policy
  resources:
  - podsecuritypolicies
  verbs:
  - use
- apiGroups:
  - status.gatekeeper.sh
  resources:
  - '*'
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - templates.gatekeeper.sh
  resources:
  - constrainttemplates
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - templates.gatekeeper.sh
  resources:
  - constrainttemplates/finalizers
  verbs:
  - delete
  - get
  - patch
  - update
- apiGroups:
  - templates.gatekeeper.sh
  resources:
  - constrainttemplates/status
  verbs:
  - get
  - patch
  - update
- apiGroups:
  - admissionregistration.k8s.io
  resourceNames:
  - gatekeeper-validating-webhook-configuration
  resources:
  - validatingwebhookconfigurations
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  creationTimestamp: null
  labels:
    gatekeeper.sh/system: "yes"
    policycontroller.configmanagement.gke.io: "true"
    policycontroller.configmanagement.gke.io/mutation: "true"
  name: gatekeeper-mutation-role
rules:
- apiGroups:
  - admissionregistration.k8s.io
  resourceNames:
  - gatekeeper-mutating-webhook-configuration
  resources:
  - mutatingwebhookconfigurations
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  labels:
    gatekeeper.sh/system: "yes"
    policycontroller.configmanagement.gke.io: "true"
  name: gatekeeper-manager-rolebinding
  namespace: gatekeeper-system
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: gatekeeper-manager-role
subjects:
- kind: ServiceAccount
  name: gatekeeper-admin
  namespace: gatekeeper-system
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  labels:
    gatekeeper.sh/system: "yes"
    policycontroller.configmanagement.gke.io: "true"
    policycontroller.configmanagement.gke.io/mutation: "true"
  name: gatekeeper-mutation-role-rolebinding
  namespace: gatekeeper-system
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: gatekeeper-mutation-role
subjects:
- kind: ServiceAccount
  name: gatekeeper-admin
  namespace: gatekeeper-system
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  labels:
    gatekeeper.sh/system: "yes"
    policycontroller.configmanagement.gke.io: "true"
  name: gatekeeper-manager-rolebinding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: gatekeeper-manager-role
subjects:
- kind: ServiceAccount
  name: gatekeeper-admin
  namespace: gatekeeper-system
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  labels:
    gatekeeper.sh/system: "yes"
    policycontroller.configmanagement.gke.io: "true"
    policycontroller.configmanagement.gke.io/mutation: "true"
  name: gatekeeper-mutation-rolebinding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: gatekeeper-mutation-role
subjects:
- kind: ServiceAccount
  name: gatekeeper-admin
  namespace: gatekeeper-system
---
apiVersion: v1
kind: Secret
metadata:
  labels:
    gatekeeper.sh/system: "yes"
    policycontroller.configmanagement.gke.io: "true"
  name: gatekeeper-webhook-server-cert
  namespace: gatekeeper-system
---
apiVersion: v1
kind: Service
metadata:
  labels:
    gatekeeper.sh/system: "yes"
    policycontroller.configmanagement.gke.io: "true"
    policycontroller.configmanagement.gke.io/mutation: "true"
  name: gatekeeper-mutation-webhook-service
  namespace: gatekeeper-system
spec:
  ports:
  - port: 443
    targetPort: mutation-server
  selector:
    control-plane: mutation-controller
    gatekeeper.sh/operation: webhook
    gatekeeper.sh/system: "yes"
    policycontroller.configmanagement.gke.io: "true"
    policycontroller.configmanagement.gke.io/mutation: "true"
---
apiVersion: v1
kind: Service
metadata:
  labels:
    gatekeeper.sh/system: "yes"
    policycontroller.configmanagement.gke.io: "true"
  name: gatekeeper-webhook-service
  namespace: gatekeeper-system
spec:
  ports:
  - port: 443
    targetPort: webhook-server
  selector:
    control-plane: controller-manager
    gatekeeper.sh/operation: webhook
    gatekeeper.sh/system: "yes"
    policycontroller.configmanagement.gke.io: "true"
---
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    control-plane: audit-controller
    gatekeeper.sh/operation: audit
    gatekeeper.sh/system: "yes"
    policycontroller.configmanagement.gke.io: "true"
  name: gatekeeper-audit
  namespace: gatekeeper-system
spec:
  replicas: 1
  selector:
    matchLabels:
      control-plane: audit-controller
      gatekeeper.sh/operation: audit
      gatekeeper.sh/system: "yes"
      policycontroller.configmanagement.gke.io: "true"
  template:
    metadata:
      annotations:
        container.seccomp.security.alpha.kubernetes.io/manager: runtime/default
      labels:
        control-plane: audit-controller
        gatekeeper.sh/operation: audit
        gatekeeper.sh/system: "yes"
        monitored: "true"
        policycontroller.configmanagement.gke.io: "true"
    spec:
      automountServiceAccountToken: true
      containers:
      - args:
        - --logtostderr
        - --operation=audit
        - --operation=status
        - --log-level-key=severity
        - --log-level-encoder=capital
        command:
        - /manager
        env:
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              apiVersion: v1
              fieldPath: metadata.namespace
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        image: gcr.io/config-management-release/gatekeeper:anthos1.8.2-07e2fd0.g0
        imagePullPolicy: Always
        livenessProbe:
          httpGet:
            path: /healthz
            port: 9090
        name: manager
        ports:
        - containerPort: 8888
          name: metrics
          protocol: TCP
        - containerPort: 9090
          name: healthz
          protocol: TCP
        readinessProbe:
          httpGet:
            path: /readyz
            port: 9090
        resources:
          limits:
            cpu: 1000m
            memory: 512Mi
          requests:
            cpu: 100m
            memory: 256Mi
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - all
          readOnlyRootFilesystem: true
          runAsGroup: 999
          runAsNonRoot: true
          runAsUser: 1000
      nodeSelector:
        kubernetes.io/os: linux
      priorityClassName: system-cluster-critical
      serviceAccountName: gatekeeper-admin
      terminationGracePeriodSeconds: 60
---
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    control-plane: controller-manager
    gatekeeper.sh/operation: webhook
    gatekeeper.sh/system: "yes"
    policycontroller.configmanagement.gke.io: "true"
  name: gatekeeper-controller-manager
  namespace: gatekeeper-system
spec:
  replicas: 1
  selector:
    matchLabels:
      control-plane: controller-manager
      gatekeeper.sh/operation: webhook
      gatekeeper.sh/system: "yes"
      policycontroller.configmanagement.gke.io: "true"
  template:
    metadata:
      annotations:
        container.seccomp.security.alpha.kubernetes.io/manager: runtime/default
      labels:
        control-plane: controller-manager
        gatekeeper.sh/operation: webhook
        gatekeeper.sh/system: "yes"
        monitored: "true"
        policycontroller.configmanagement.gke.io: "true"
    spec:
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - podAffinityTerm:
              labelSelector:
                matchExpressions:
                - key: gatekeeper.sh/operation
                  operator: In
                  values:
                  - webhook
              topologyKey: kubernetes.io/hostname
            weight: 100
      automountServiceAccountToken: true
      containers:
      - args:
        - --port=10250
        - --logtostderr
        - --exempt-namespace=gatekeeper-system
        - --operation=webhook
        - --log-level-key=severity
        - --log-level-encoder=capital
        command:
        - /manager
        env:
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              apiVersion: v1
              fieldPath: metadata.namespace
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        image: gcr.io/config-management-release/gatekeeper:anthos1.8.2-07e2fd0.g0
        imagePullPolicy: Always
        livenessProbe:
          httpGet:
            path: /healthz
            port: 9090
        name: manager
        ports:
        - containerPort: 10250
          name: webhook-server
          protocol: TCP
        - containerPort: 8888
          name: metrics
          protocol: TCP
        - containerPort: 9090
          name: healthz
          protocol: TCP
        readinessProbe:
          httpGet:
            path: /readyz
            port: 9090
        resources:
          limits:
            cpu: 1000m
            memory: 512Mi
          requests:
            cpu: 100m
            memory: 256Mi
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - all
          readOnlyRootFilesystem: true
          runAsGroup: 999
          runAsNonRoot: true
          runAsUser: 1000
        volumeMounts:
        - mountPath: /certs
          name: cert
          readOnly: true
      nodeSelector:
        kubernetes.io/os: linux
      priorityClassName: system-cluster-critical
      serviceAccountName: gatekeeper-admin
      terminationGracePeriodSeconds: 60
      volumes:
      - name: cert
        secret:
          defaultMode: 420
          secretName: gatekeeper-webhook-server-cert
---
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    control-plane: mutation-controller
    gatekeeper.sh/operation: mutation-status
    gatekeeper.sh/system: "yes"
    policycontroller.configmanagement.gke.io: "true"
    policycontroller.configmanagement.gke.io/mutation: "true"
  name: gatekeeper-mutation
  namespace: gatekeeper-system
spec:
  replicas: 1
  selector:
    matchLabels:
      control-plane: mutation-controller
      gatekeeper.sh/operation: webhook
      gatekeeper.sh/system: "yes"
      policycontroller.configmanagement.gke.io: "true"
      policycontroller.configmanagement.gke.io/mutation: "true"
  template:
    metadata:
      annotations:
        container.seccomp.security.alpha.kubernetes.io/manager: runtime/default
      labels:
        control-plane: mutation-controller
        gatekeeper.sh/operation: webhook
        gatekeeper.sh/system: "yes"
        policycontroller.configmanagement.gke.io: "true"
        policycontroller.configmanagement.gke.io/mutation: "true"
    spec:
      automountServiceAccountToken: true
      containers:
      - args:
        - --port=10250
        - --enable-mutation=true
        - --operation=webhook
        - --operation=mutation-status
        - --logtostderr
        command:
        - /manager
        env:
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              apiVersion: v1
              fieldPath: metadata.namespace
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        image: gcr.io/config-management-release/gatekeeper:anthos1.8.2-07e2fd0.g0
        imagePullPolicy: Always
        livenessProbe:
          httpGet:
            path: /healthz
            port: 9090
        name: manager
        ports:
        - containerPort: 10250
          name: mutation-server
        - containerPort: 8888
          name: metrics
          protocol: TCP
        - containerPort: 9090
          name: healthz
          protocol: TCP
        readinessProbe:
          httpGet:
            path: /readyz
            port: 9090
        resources:
          limits:
            cpu: 1000m
            memory: 512Mi
          requests:
            cpu: 100m
            memory: 256Mi
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - all
          readOnlyRootFilesystem: true
          runAsGroup: 999
          runAsNonRoot: true
          runAsUser: 1000
        volumeMounts:
        - mountPath: /certs
          name: cert
          readOnly: true
      nodeSelector:
        kubernetes.io/os: linux
      serviceAccountName: gatekeeper-admin
      terminationGracePeriodSeconds: 60
      volumes:
      - name: cert
        secret:
          defaultMode: 420
          secretName: gatekeeper-webhook-server-cert
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Requires that service port names have a prefix from a specified list. Introduced in ACM v1.4.0.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: allowedserviceportname
spec:
  crd:
    spec:
      names:
        kind: AllowedServicePortName
      validation:
        openAPIV3Schema:
          properties:
            prefixes:
              items:
                type: string
              type: array
  targets:
  - rego: |
      package asm.guardrails.allowedserviceportname

      violation[{"msg": msg}] {
        service := input.review.object
        port := service.spec.ports[_]
        prefixes := input.parameters.prefixes

        not is_prefixed(port, prefixes)

        msg := "service port name missing prefix"
      }

      is_prefixed(port, prefixes) {
        prefix := prefixes[_]
        startswith(port.name, prefix)
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Prohibits disabling TLS for all hosts and host subsets in Istio DestinationRules. Introduced in ACM v1.4.0.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: destinationruletlsenabled
spec:
  crd:
    spec:
      names:
        kind: DestinationRuleTLSEnabled
      validation:
        openAPIV3Schema: {}
  targets:
  - rego: |
      package asm.guardrails.destinationruletlsenabled

      # spec.trafficPolicy.tls.mode == DISABLE
      violation[{"msg": msg}] {
        d := input.review.object

        d.apiVersion == "networking.istio.io/v1alpha3"
        d.kind == "DestinationRule"

        tpl := d.spec.trafficPolicy[_]

        tpl == {"mode": "DISABLE"}

        msg := sprintf("spec.trafficPolicy.tls.mode == DISABLE for host(s): %v", [d.spec.host])
      }

      # spec.subsets[].trafficPolicy.tls.mode == DISABLE
      violation[{"msg": msg}] {
        d := input.review.object

        d.apiVersion == "networking.istio.io/v1alpha3"
        d.kind == "DestinationRule"

        subset := d.spec.subsets[_]
        subset.trafficPolicy == {"tls": {"mode": "DISABLE"}}

        msg := sprintf("subsets[].trafficPolicy.tls.mode == DISABLE for host-subset: %v-%v", [d.spec.host, subset.name])
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Requires that principals and namespaces in Istio `AuthorizationPolicy` rules don't have a prefix from a specified list. Introduced in ACM v1.4.0.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: disallowedauthzprefix
spec:
  crd:
    spec:
      names:
        kind: DisallowedAuthzPrefix
      validation:
        openAPIV3Schema:
          properties:
            disallowedprefixes:
              items:
                type: string
              type: array
  targets:
  - rego: |
      package asm.guardrails.disallowedauthzprefix

      violation[{"msg": msg}] {
        p := input.review.object

        p.apiVersion == "security.istio.io/v1beta1"
        p.kind == "AuthorizationPolicy"

        rule := p.spec.rules[_]
        from := rule.from[_]

        principal := from.source.principals[_]
        parts := split(principal, "/")

        badprefix := input.parameters.disallowedprefixes[_]

        # check the final component of source.principals, the service account name
        startswith(parts[minus(count(parts), 1)], badprefix)

        msg := sprintf("source.principals '%v' cannot begin with '%v'", [principal, badprefix])
      }

      violation[{"msg": msg}] {
        p := input.review.object

        p.apiVersion == "security.istio.io/v1beta1"
        p.kind == "AuthorizationPolicy"

        rule := p.spec.rules[_]
        from := rule.from[_]

        namespace := from.source.namespaces[_]

        badprefix := input.parameters.disallowedprefixes[_]
        startswith(namespace, badprefix)

        msg := sprintf("source.namespaces '%v' cannot begin with '%v'", [namespace, badprefix])
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Restricts the permitted `locations` for StorageBucket Config Connector resources. Bucket names in the `exemptions` list are exempt. Introduced in ACM v1.6.1.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: gcpstoragelocationconstraintv1
spec:
  crd:
    spec:
      names:
        kind: GCPStorageLocationConstraintV1
      validation:
        openAPIV3Schema:
          properties:
            exemptions:
              items:
                type: string
              type: array
            locations:
              items:
                type: string
              type: array
  targets:
  - rego: |
      package gcpstoragelocationconstraintv1

      allowedLocation(reviewLocation) {
        locations := input.parameters.locations
        satisfied := [good |
          location = locations[_]
          good = lower(location) == lower(reviewLocation)
        ]

        any(satisfied)
      }

      exempt(reviewName) {
        input.parameters.exemptions[_] == reviewName
      }

      violation[{"msg": msg}] {
        bucketName := input.review.object.metadata.name
        bucketLocation := input.review.object.spec.location
        not allowedLocation(bucketLocation)
        not exempt(bucketName)
        msg := sprintf("Cloud Storage bucket <%v> uses a disallowed location <%v>, allowed locations are %v", [bucketName, bucketLocation, input.parameters.locations])
      }

      violation[{"msg": msg}] {
        not input.parameters.locations
        bucketName := input.review.object.metadata.name
        msg := sprintf("No permitted locations for Cloud Storage bucket <%v>", [bucketName])
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Requires container images to begin with a repo string from a specified list.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: k8sallowedrepos
spec:
  crd:
    spec:
      names:
        kind: K8sAllowedRepos
      validation:
        openAPIV3Schema:
          properties:
            repos:
              items:
                type: string
              type: array
  targets:
  - rego: |
      package k8sallowedrepos

      violation[{"msg": msg}] {
        container := input.review.object.spec.containers[_]
        satisfied := [good | repo = input.parameters.repos[_]; good = startswith(container.image, repo)]
        not any(satisfied)
        msg := sprintf("container <%v> has an invalid image repo <%v>, allowed repos are %v", [container.name, container.image, input.parameters.repos])
      }

      violation[{"msg": msg}] {
        container := input.review.object.spec.initContainers[_]
        satisfied := [good | repo = input.parameters.repos[_]; good = startswith(container.image, repo)]
        not any(satisfied)
        msg := sprintf("container <%v> has an invalid image repo <%v>, allowed repos are %v", [container.name, container.image, input.parameters.repos])
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Disallows all Services with type NodePort.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: k8sblocknodeport
spec:
  crd:
    spec:
      names:
        kind: K8sBlockNodePort
  targets:
  - rego: |
      package k8sblocknodeport

      violation[{"msg": msg}] {
        input.review.kind.kind == "Service"
        input.review.object.spec.type == "NodePort"
        msg := "User is not allowed to create service of type NodePort"
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Prohibits Pod specs with `shareProcessNamespace` set to `true`. This avoids scenarios where all containers in a Pod share a PID namespace and can access each other's filesystem and memory. Introduced in ACM v1.3.1.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: k8sblockprocessnamespacesharing
spec:
  crd:
    spec:
      names:
        kind: K8sBlockProcessNamespaceSharing
      validation:
        openAPIV3Schema: {}
  targets:
  - rego: |
      package k8sblockprocessnamespacesharing

      violation[{"msg": msg}] {
        input.review.kind.group == ""
        input.review.kind.kind == "Pod"
        input.review.object.spec.shareProcessNamespace == true
        msg := "Process namespace sharing is not allowed"
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Requires containers to have memory and CPU limits set and within a specified maximum amount.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: k8scontainerlimits
spec:
  crd:
    spec:
      names:
        kind: K8sContainerLimits
      validation:
        openAPIV3Schema:
          properties:
            cpu:
              type: string
            memory:
              type: string
  targets:
  - rego: |
      package k8scontainerlimits

      missing(obj, field) {
        not obj[field]
      }

      missing(obj, field) {
        obj[field] == ""
      }

      canonify_cpu(orig) = new {
        is_number(orig)
        new := orig * 1000
      }

      canonify_cpu(orig) = new {
        not is_number(orig)
        endswith(orig, "m")
        new := to_number(replace(orig, "m", ""))
      }

      canonify_cpu(orig) = new {
        not is_number(orig)
        not endswith(orig, "m")
        re_match("^[0-9]+$", orig)
        new := to_number(orig) * 1000
      }

      # 10 ** 21
      mem_multiple("E") = 1000000000000000000000

      # 10 ** 18
      mem_multiple("P") = 1000000000000000000

      # 10 ** 15
      mem_multiple("T") = 1000000000000000

      # 10 ** 12
      mem_multiple("G") = 1000000000000

      # 10 ** 9
      mem_multiple("M") = 1000000000

      # 10 ** 6
      mem_multiple("k") = 1000000

      # 10 ** 3
      mem_multiple("") = 1000

      # Kubernetes accepts millibyte precision when it probably shouldn't.
      # https://github.com/kubernetes/kubernetes/issues/28741
      # 10 ** 0
      mem_multiple("m") = 1

      # 1000 * 2 ** 10
      mem_multiple("Ki") = 1024000

      # 1000 * 2 ** 20
      mem_multiple("Mi") = 1048576000

      # 1000 * 2 ** 30
      mem_multiple("Gi") = 1073741824000

      # 1000 * 2 ** 40
      mem_multiple("Ti") = 1099511627776000

      # 1000 * 2 ** 50
      mem_multiple("Pi") = 1125899906842624000

      # 1000 * 2 ** 60
      mem_multiple("Ei") = 1152921504606846976000

      get_suffix(mem) = suffix {
        not is_string(mem)
        suffix := ""
      }

      get_suffix(mem) = suffix {
        is_string(mem)
        count(mem) > 0
        suffix := substring(mem, count(mem) - 1, -1)
        mem_multiple(suffix)
      }

      get_suffix(mem) = suffix {
        is_string(mem)
        count(mem) > 1
        suffix := substring(mem, count(mem) - 2, -1)
        mem_multiple(suffix)
      }

      get_suffix(mem) = suffix {
        is_string(mem)
        count(mem) > 1
        not mem_multiple(substring(mem, count(mem) - 1, -1))
        not mem_multiple(substring(mem, count(mem) - 2, -1))
        suffix := ""
      }

      get_suffix(mem) = suffix {
        is_string(mem)
        count(mem) == 1
        not mem_multiple(substring(mem, count(mem) - 1, -1))
        suffix := ""
      }

      get_suffix(mem) = suffix {
        is_string(mem)
        count(mem) == 0
        suffix := ""
      }

      canonify_mem(orig) = new {
        is_number(orig)
        new := orig * 1000
      }

      canonify_mem(orig) = new {
        not is_number(orig)
        suffix := get_suffix(orig)
        raw := replace(orig, suffix, "")
        re_match("^[0-9]+$", raw)
        new := to_number(raw) * mem_multiple(suffix)
      }

      violation[{"msg": msg}] {
        general_violation[{"field": "containers", "msg": msg}]
      }

      violation[{"msg": msg}] {
        general_violation[{"field": "initContainers", "msg": msg}]
      }

      general_violation[{"msg": msg, "field": field}] {
        container := input.review.object.spec[field][_]
        cpu_orig := container.resources.limits.cpu
        not canonify_cpu(cpu_orig)
        msg := sprintf("container <%v> cpu limit <%v> could not be parsed", [container.name, cpu_orig])
      }

      general_violation[{"msg": msg, "field": field}] {
        container := input.review.object.spec[field][_]
        mem_orig := container.resources.limits.memory
        not canonify_mem(mem_orig)
        msg := sprintf("container <%v> memory limit <%v> could not be parsed", [container.name, mem_orig])
      }

      general_violation[{"msg": msg, "field": field}] {
        container := input.review.object.spec[field][_]
        not container.resources
        msg := sprintf("container <%v> has no resource limits", [container.name])
      }

      general_violation[{"msg": msg, "field": field}] {
        container := input.review.object.spec[field][_]
        not container.resources.limits
        msg := sprintf("container <%v> has no resource limits", [container.name])
      }

      general_violation[{"msg": msg, "field": field}] {
        container := input.review.object.spec[field][_]
        missing(container.resources.limits, "cpu")
        msg := sprintf("container <%v> has no cpu limit", [container.name])
      }

      general_violation[{"msg": msg, "field": field}] {
        container := input.review.object.spec[field][_]
        missing(container.resources.limits, "memory")
        msg := sprintf("container <%v> has no memory limit", [container.name])
      }

      general_violation[{"msg": msg, "field": field}] {
        container := input.review.object.spec[field][_]
        cpu_orig := container.resources.limits.cpu
        cpu := canonify_cpu(cpu_orig)
        max_cpu_orig := input.parameters.cpu
        max_cpu := canonify_cpu(max_cpu_orig)
        cpu > max_cpu
        msg := sprintf("container <%v> cpu limit <%v> is higher than the maximum allowed of <%v>", [container.name, cpu_orig, max_cpu_orig])
      }

      general_violation[{"msg": msg, "field": field}] {
        container := input.review.object.spec[field][_]
        mem_orig := container.resources.limits.memory
        mem := canonify_mem(mem_orig)
        max_mem_orig := input.parameters.memory
        max_mem := canonify_mem(max_mem_orig)
        mem > max_mem
        msg := sprintf("container <%v> memory limit <%v> is higher than the maximum allowed of <%v>", [container.name, mem_orig, max_mem_orig])
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Sets a maximum ratio for container resource limits to requests.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: k8scontainerratios
spec:
  crd:
    spec:
      names:
        kind: K8sContainerRatios
      validation:
        openAPIV3Schema:
          properties:
            ratio:
              type: string
  targets:
  - rego: |
      package k8scontainerratios

      missing(obj, field) {
        not obj[field]
      }

      missing(obj, field) {
        obj[field] == ""
      }

      canonify_cpu(orig) = new {
        is_number(orig)
        new := orig * 1000
      }

      canonify_cpu(orig) = new {
        not is_number(orig)
        endswith(orig, "m")
        new := to_number(replace(orig, "m", ""))
      }

      canonify_cpu(orig) = new {
        not is_number(orig)
        not endswith(orig, "m")
        re_match("^[0-9]+$", orig)
        new := to_number(orig) * 1000
      }

      canonify_cpu(orig) = new {
        not is_number(orig)
        not endswith(orig, "m")
        re_match("^[0-9]+[.][0-9]+$", orig)
        new := to_number(orig) * 1000
      }

      # 10 ** 21
      mem_multiple("E") = 1000000000000000000000

      # 10 ** 18
      mem_multiple("P") = 1000000000000000000

      # 10 ** 15
      mem_multiple("T") = 1000000000000000

      # 10 ** 12
      mem_multiple("G") = 1000000000000

      # 10 ** 9
      mem_multiple("M") = 1000000000

      # 10 ** 6
      mem_multiple("k") = 1000000

      # 10 ** 3
      mem_multiple("") = 1000

      # Kubernetes accepts millibyte precision when it probably shouldn't.
      # https://github.com/kubernetes/kubernetes/issues/28741
      # 10 ** 0
      mem_multiple("m") = 1

      # 1000 * 2 ** 10
      mem_multiple("Ki") = 1024000

      # 1000 * 2 ** 20
      mem_multiple("Mi") = 1048576000

      # 1000 * 2 ** 30
      mem_multiple("Gi") = 1073741824000

      # 1000 * 2 ** 40
      mem_multiple("Ti") = 1099511627776000

      # 1000 * 2 ** 50
      mem_multiple("Pi") = 1125899906842624000

      # 1000 * 2 ** 60
      mem_multiple("Ei") = 1152921504606846976000

      get_suffix(mem) = suffix {
        not is_string(mem)
        suffix := ""
      }

      get_suffix(mem) = suffix {
        is_string(mem)
        count(mem) > 0
        suffix := substring(mem, count(mem) - 1, -1)
        mem_multiple(suffix)
      }

      get_suffix(mem) = suffix {
        is_string(mem)
        count(mem) > 1
        suffix := substring(mem, count(mem) - 2, -1)
        mem_multiple(suffix)
      }

      get_suffix(mem) = suffix {
        is_string(mem)
        count(mem) > 1
        not mem_multiple(substring(mem, count(mem) - 1, -1))
        not mem_multiple(substring(mem, count(mem) - 2, -1))
        suffix := ""
      }

      get_suffix(mem) = suffix {
        is_string(mem)
        count(mem) == 1
        not mem_multiple(substring(mem, count(mem) - 1, -1))
        suffix := ""
      }

      get_suffix(mem) = suffix {
        is_string(mem)
        count(mem) == 0
        suffix := ""
      }

      canonify_mem(orig) = new {
        is_number(orig)
        new := orig * 1000
      }

      canonify_mem(orig) = new {
        not is_number(orig)
        suffix := get_suffix(orig)
        raw := replace(orig, suffix, "")
        re_match("^[0-9]+$", raw)
        new := to_number(raw) * mem_multiple(suffix)
      }

      violation[{"msg": msg}] {
        general_violation[{"field": "containers", "msg": msg}]
      }

      violation[{"msg": msg}] {
        general_violation[{"field": "initContainers", "msg": msg}]
      }

      general_violation[{"msg": msg, "field": field}] {
        container := input.review.object.spec[field][_]
        cpu_orig := container.resources.limits.cpu
        not canonify_cpu(cpu_orig)
        msg := sprintf("container <%v> cpu limit <%v> could not be parsed", [container.name, cpu_orig])
      }

      general_violation[{"msg": msg, "field": field}] {
        container := input.review.object.spec[field][_]
        mem_orig := container.resources.limits.memory
        not canonify_mem(mem_orig)
        msg := sprintf("container <%v> memory limit <%v> could not be parsed", [container.name, mem_orig])
      }

      general_violation[{"msg": msg, "field": field}] {
        container := input.review.object.spec[field][_]
        cpu_orig := container.resources.requests.cpu
        not canonify_cpu(cpu_orig)
        msg := sprintf("container <%v> cpu request <%v> could not be parsed", [container.name, cpu_orig])
      }

      general_violation[{"msg": msg, "field": field}] {
        container := input.review.object.spec[field][_]
        mem_orig := container.resources.requests.memory
        not canonify_mem(mem_orig)
        msg := sprintf("container <%v> memory request <%v> could not be parsed", [container.name, mem_orig])
      }

      general_violation[{"msg": msg, "field": field}] {
        container := input.review.object.spec[field][_]
        not container.resources
        msg := sprintf("container <%v> has no resource limits", [container.name])
      }

      general_violation[{"msg": msg, "field": field}] {
        container := input.review.object.spec[field][_]
        not container.resources.limits
        msg := sprintf("container <%v> has no resource limits", [container.name])
      }

      general_violation[{"msg": msg, "field": field}] {
        container := input.review.object.spec[field][_]
        missing(container.resources.limits, "cpu")
        msg := sprintf("container <%v> has no cpu limit", [container.name])
      }

      general_violation[{"msg": msg, "field": field}] {
        container := input.review.object.spec[field][_]
        missing(container.resources.limits, "memory")
        msg := sprintf("container <%v> has no memory limit", [container.name])
      }

      general_violation[{"msg": msg, "field": field}] {
        container := input.review.object.spec[field][_]
        not container.resources.requests
        msg := sprintf("container <%v> has no resource requests", [container.name])
      }

      general_violation[{"msg": msg, "field": field}] {
        container := input.review.object.spec[field][_]
        missing(container.resources.requests, "cpu")
        msg := sprintf("container <%v> has no cpu request", [container.name])
      }

      general_violation[{"msg": msg, "field": field}] {
        container := input.review.object.spec[field][_]
        missing(container.resources.requests, "memory")
        msg := sprintf("container <%v> has no memory request", [container.name])
      }

      general_violation[{"msg": msg, "field": field}] {
        container := input.review.object.spec[field][_]
        cpu_limits_orig := container.resources.limits.cpu
        cpu_limits := canonify_cpu(cpu_limits_orig)
        cpu_requests_orig := container.resources.requests.cpu
        cpu_requests := canonify_cpu(cpu_requests_orig)
        cpu_ratio := input.parameters.ratio
        to_number(cpu_limits) > to_number(cpu_ratio) * to_number(cpu_requests)
        msg := sprintf("container <%v> cpu limit <%v> is higher than the maximum allowed ratio of <%v>", [container.name, cpu_limits_orig, cpu_ratio])
      }

      general_violation[{"msg": msg, "field": field}] {
        container := input.review.object.spec[field][_]
        mem_limits_orig := container.resources.limits.memory
        mem_requests_orig := container.resources.requests.memory
        mem_limits := canonify_mem(mem_limits_orig)
        mem_requests := canonify_mem(mem_requests_orig)
        mem_ratio := input.parameters.ratio
        to_number(mem_limits) > to_number(mem_ratio) * to_number(mem_requests)
        msg := sprintf("container <%v> memory limit <%v> is higher than the maximum allowed ratio of <%v>", [container.name, mem_limits_orig, mem_ratio])
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Prohibits RoleBindings or ClusterRoleBindings with subjects matching any `disallowedSubjects` passed as parameters. Introduced in ACM v1.3.1.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: k8sdisallowedrolebindingsubjects
spec:
  crd:
    spec:
      names:
        kind: K8sDisallowedRoleBindingSubjects
      validation:
        openAPIV3Schema:
          properties:
            disallowedSubjects:
              items:
                properties:
                  apiGroup:
                    type: string
                  kind:
                    type: string
                  name:
                    type: string
                type: object
              type: array
  targets:
  - rego: |
      package k8sdisallowedrolebindingsubjects

      is_rolebinding_or_cluster_rolebinding(kind) {
        kind.group == "rbac.authorization.k8s.io"
        kinds := {"RoleBinding", "ClusterRoleBinding"}
        kinds[kind.kind]
      }

      violation[{"msg": msg}] {
        is_rolebinding_or_cluster_rolebinding(input.review.kind)
        disallowedSubject := input.parameters.disallowedSubjects[_]
        inputSubject := input.review.object.subjects[_]
        disallowedSubject.name == inputSubject.name
        disallowedSubject.kind == inputSubject.kind
        disallowedSubject.apiGroup == inputSubject.apiGroup
        msg := sprintf("<%v> has disallowed apiGroup <%v>, kind <%v> and name <%v>", [input.review.object.metadata.name, inputSubject.apiGroup, inputSubject.kind, inputSubject.name])
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Requires container images to have an image tag different from the ones in a specified list.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: k8sdisallowedtags
spec:
  crd:
    spec:
      names:
        kind: K8sDisallowedTags
      validation:
        openAPIV3Schema:
          properties:
            tags:
              items:
                type: string
              type: array
  targets:
  - rego: |
      package k8sdisallowedtags

      violation[{"msg": msg}] {
        container := input_containers[_]
        tags := [forbid | tag = input.parameters.tags[_]; forbid = endswith(container.image, concat(":", ["", tag]))]
        any(tags)
        msg := sprintf("container <%v> uses a disallowed tag <%v>; disallowed tags are %v", [container.name, container.image, input.parameters.tags])
      }

      violation[{"msg": msg}] {
        container := input_containers[_]
        tag := [contains(container.image, ":")]
        not all(tag)
        msg := sprintf("container <%v> didn't specify an image tag <%v>", [container.name, container.image])
      }

      input_containers[c] {
        c := input.review.object.spec.containers[_]
      }

      input_containers[c] {
        c := input.review.object.spec.initContainers[_]
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Requires that any `emptyDir` volumes specify a `sizeLimit`; optionally, a `maxSizeLimit` parameter can be supplied in the constraint to specify a maximum allowable size limit. Introduced in ACM v1.3.1.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: k8semptydirhassizelimit
spec:
  crd:
    spec:
      names:
        kind: K8sEmptyDirHasSizeLimit
      validation:
        openAPIV3Schema:
          properties:
            maxSizeLimit:
              type: string
  targets:
  - rego: |
      package k8semptydirhassizelimit

      violation[{"msg": msg}] {
        input.review.kind.group == ""
        input.review.kind.kind == "Pod"
        volume := input.review.object.spec.volumes[i]
        volume.emptyDir
        not volume.emptyDir.sizeLimit
        msg := sprintf("emptyDir volume <%v> must have a size limit", [volume_identifier(volume, i)])
      }

      violation[{"msg": msg}] {
        input.review.kind.group == ""
        input.review.kind.kind == "Pod"
        volume := input.review.object.spec.volumes[i]
        canonify_bytes(volume.emptyDir.sizeLimit) > canonify_bytes(input.parameters.maxSizeLimit)
        msg := sprintf("emptyDir volume <%v> size limit <%v> exceeds maximum <%v>", [volume_identifier(volume, i), volume.emptyDir.sizeLimit, input.parameters.maxSizeLimit])
      }

      violation[{"msg": msg}] {
        input.review.kind.group == ""
        input.review.kind.kind == "Pod"
        volume := input.review.object.spec.volumes[i]
        volume.emptyDir.sizeLimit
        not is_number_or_e_notation(volume.emptyDir.sizeLimit)
        not is_number_with_suffix(volume.emptyDir.sizeLimit)
        msg := sprintf("emptyDir volume <%v> size limit <%v> could not be parsed as bytes", [volume_identifier(volume, i), volume.emptyDir.sizeLimit])
      }

      violation[{"msg": msg}] {
        input.review.kind.group == ""
        input.review.kind.kind == "Pod"
        input.parameters.maxSizeLimit
        not is_number_or_e_notation(input.parameters.maxSizeLimit)
        not is_number_with_suffix(input.parameters.maxSizeLimit)
        msg := sprintf("emptyDir volume max size limit <%v> could not be parsed as bytes", [input.parameters.maxSizeLimit])
      }

      readable_volume_name(name) {
        name != false
        name != null
        name != ""
        name
      }

      volume_identifier(volume, i) = name {
        readable_volume_name(volume.name)
        name := volume.name
      }

      volume_identifier(volume, i) = name {
        not readable_volume_name(volume.name)
        name := i
      }

      is_number_or_e_notation(n) {
        re_match("^[0-9]*(\\.?[0-9]+)?(e[-+]?[0-9]+)?$", sprintf("%v", [n]))
      }

      is_number_with_suffix(n) {
        re_match("^[0-9]+(\\.[0-9]+)?[EePpTtGgMmKk]i?$", sprintf("%v", [n]))
      }

      canonify_bytes(n) = n_bytes {
        is_number_or_e_notation(n)
        n_bytes := to_number(n)
      }

      canonify_bytes(n) = n_bytes {
        is_number_with_suffix(n)
        n_bytes := units.parse_bytes(sprintf("%vB", [n]))
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Restricts Services from containing externalIPs except those in a provided allowlist.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: k8sexternalips
spec:
  crd:
    spec:
      names:
        kind: K8sExternalIPs
      validation:
        openAPIV3Schema:
          properties:
            allowedIPs:
              items:
                type: string
              type: array
  targets:
  - rego: |
      package k8sexternalips

      violation[{"msg": msg}] {
        input.review.kind.kind == "Service"
        input.review.kind.group == ""
        allowedIPs := {ip | ip := input.parameters.allowedIPs[_]}
        externalIPs := {ip | ip := input.review.object.spec.externalIPs[_]}
        forbiddenIPs := externalIPs - allowedIPs
        count(forbiddenIPs) > 0
        msg := sprintf("service has forbidden external IPs: %v", [forbiddenIPs])
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Requires Ingress resources to be HTTPS only; TLS configuration should be set and `kubernetes.io/ingress.allow-http` annotation equals false.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: k8shttpsonly
spec:
  crd:
    spec:
      names:
        kind: K8sHttpsOnly
  targets:
  - rego: |
      package k8shttpsonly

      violation[{"msg": msg}] {
        input.review.object.kind == "Ingress"
        re_match("^(extensions|networking.k8s.io)/", input.review.object.apiVersion)
        ingress := input.review.object
        not https_complete(ingress)
        msg := sprintf("Ingress should be https. tls configuration and allow-http=false annotation are required for %v", [ingress.metadata.name])
      }

      https_complete(ingress) {
        ingress.spec.tls
        count(ingress.spec.tls) > 0
        ingress.metadata.annotations["kubernetes.io/ingress.allow-http"] == "false"
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Requires container images to contain a digest.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: k8simagedigests
spec:
  crd:
    spec:
      names:
        kind: K8sImageDigests
  targets:
  - rego: |
      package k8simagedigests

      violation[{"msg": msg}] {
        container := input.review.object.spec.containers[_]
        satisfied := [re_match("@[a-z0-9]+([+._-][a-z0-9]+)*:[a-zA-Z0-9=_-]+", container.image)]
        not all(satisfied)
        msg := sprintf("container <%v> uses an image without a digest <%v>", [container.name, container.image])
      }

      violation[{"msg": msg}] {
        container := input.review.object.spec.initContainers[_]
        satisfied := [re_match("@[a-z0-9]+([+._-][a-z0-9]+)*:[a-zA-Z0-9=_-]+", container.image)]
        not all(satisfied)
        msg := sprintf("initContainer <%v> uses an image without a digest <%v>", [container.name, container.image])
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: 'Requires Pods using local storage (`emptyDir` or `hostPath`) to have the annotation `"cluster-autoscaler.kubernetes.io/safe-to-evict": "true"`. Cluster Autoscaler will not delete Pods without this annotation. Introduced in ACM v1.3.1.'
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: k8slocalstoragerequiresafetoevict
spec:
  crd:
    spec:
      names:
        kind: K8sLocalStorageRequireSafeToEvict
      validation:
        openAPIV3Schema: {}
  targets:
  - rego: |
      package k8slocalstoragerequiresafetoevict

      has_local_storage(volumes) {
        volumes[_].emptyDir
      }

      has_local_storage(volumes) {
        volumes[_].hostPath
      }

      violation[{"msg": msg}] {
        input.review.kind.group == ""
        input.review.kind.kind == "Pod"
        has_local_storage(input.review.object.spec.volumes)
        not input.review.object.metadata.annotations["cluster-autoscaler.kubernetes.io/safe-to-evict"] == "true"
        msg := "Annotation cluster-autoscaler.kubernetes.io/safe-to-evict must be present and set to true"
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Promotes Pod stability by requiring that all containers' requested memory exactly equals the memory limit, so that Pods are never in a state where memory usage exceeds the requested amount. Kubernetes can terminate Pods in that state when memory is needed. Introduced in ACM v1.3.1.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: k8smemoryrequestequalslimit
spec:
  crd:
    spec:
      names:
        kind: K8sMemoryRequestEqualsLimit
      validation:
        openAPIV3Schema: {}
  targets:
  - rego: |
      package k8smemoryrequestequalslimit

      missing_or_empty(obj, field) {
        not obj[field]
      }

      missing_or_empty(obj, field) {
        obj[field] == ""
      }

      missing_or_empty(obj, field) {
        obj[field] == {}
      }

      violation[{"msg": msg}] {
        input.review.kind.group == ""
        input.review.kind.kind == "Pod"
        field_violation[{"field": "containers", "msg": msg}]
      }

      violation[{"msg": msg}] {
        input.review.kind.group == ""
        input.review.kind.kind == "Pod"
        field_violation[{"field": "initContainers", "msg": msg}]
      }

      field_violation[{"msg": msg, "field": field}] {
        container := input.review.object.spec[field][_]
        missing_or_empty(container.resources.requests, "memory")
        msg := sprintf("container <%v> must have a memory request", [container.name])
      }

      field_violation[{"msg": msg, "field": field}] {
        container := input.review.object.spec[field][_]
        missing_or_empty(container, "resources")
        msg := sprintf("container <%v> has no resources", [container.name])
      }

      field_violation[{"msg": msg, "field": field}] {
        container := input.review.object.spec[field][_]
        missing_or_empty(container.resources, "limits")
        msg := sprintf("container <%v> has no resource limits", [container.name])
      }

      field_violation[{"msg": msg, "field": field}] {
        container := input.review.object.spec[field][_]
        missing_or_empty(container.resources, "requests")
        msg := sprintf("container <%v> has no resource requests", [container.name])
      }

      field_violation[{"msg": msg, "field": field}] {
        container := input.review.object.spec[field][_]
        missing_or_empty(container.resources.limits, "memory")
        msg := sprintf("container <%v> has no memory limit", [container.name])
      }

      field_violation[{"msg": msg, "field": field}] {
        container := input.review.object.spec[field][_]
        mem_lim := canonify_bytes(container.resources.limits.memory)
        mem_req := canonify_bytes(container.resources.requests.memory)
        mem_req != mem_lim
        msg := sprintf("Container <%v> memory request <%v> must exactly equal limit <%v>", [container.name, container.resources.requests.memory, container.resources.limits.memory])
      }

      field_violation[{"msg": msg, "field": field}] {
        container := input.review.object.spec[field][_]
        not is_number_or_e_notation(container.resources.limits.memory)
        not is_number_with_suffix(container.resources.limits.memory)
        msg := sprintf("Container <%v> memory limit <%v> could not be parsed as bytes", [container.name, container.resources.limits.memory])
      }

      field_violation[{"msg": msg, "field": field}] {
        container := input.review.object.spec[field][_]
        not is_number_or_e_notation(container.resources.requests.memory)
        not is_number_with_suffix(container.resources.requests.memory)
        msg := sprintf("Container <%v> memory request <%v> could not be parsed as bytes", [container.name, container.resources.requests.memory])
      }

      is_number_or_e_notation(n) {
        re_match("^[0-9]*(\\.?[0-9]+)?(e[-+]?[0-9]+)?$", sprintf("%v", [n]))
      }

      is_number_with_suffix(n) {
        re_match("^[0-9]+(\\.[0-9]+)?[EePpTtGgMmKk]i?$", sprintf("%v", [n]))
      }

      canonify_bytes(n) = n_bytes {
        is_number_or_e_notation(n)
        n_bytes := to_number(n)
      }

      canonify_bytes(n) = n_bytes {
        is_number_with_suffix(n)
        n_bytes := units.parse_bytes(sprintf("%vB", [n]))
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Prohibits secrets as environment variables in container definitions; instead, use mounted secret files in data volumes. Introduced in ACM v1.5.2.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: k8snoenvvarsecrets
spec:
  crd:
    spec:
      names:
        kind: K8sNoEnvVarSecrets
      validation:
        openAPIV3Schema: {}
  targets:
  - rego: |
      package k8snoenvvarsecrets

      violation[{"msg": msg}] {
        input.review.kind.kind == "Pod"
        container := input.review.object.spec.containers[_]
        env_var := container.env[_]
        env_var.valueFrom.secretKeyRef
        msg := sprintf("Container <%v> has secret defined as environment variable", [container.name])
      }

      violation[{"msg": msg}] {
        input.review.kind.kind == "Pod"
        initContainer := input.review.object.spec.initContainers[_]
        env_var := initContainer.env[_]
        env_var.valueFrom.secretKeyRef
        msg := sprintf("initContainer <%v> has secret defined as environment variable", [initContainer.name])
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: 'Prohibits the creation of Gateway, Ingress, and Service resources that expose workloads to external IPs.<ul><li>Gateway: All resources of group `networking.istio.io` are prohibited.</li><li>Ingress: All resources of group `extensions` or `networking.k8s.io` are prohibited. </li><li>Service: All `LoadBalancer` type resources must have `Internal` annotation; any `externalIPs` must belong to the CIDRs specified by the `internalCIDRs` parameter.</li></ul> Introduced in ACM v1.3.0.'
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: k8snoexternalservices
spec:
  crd:
    spec:
      names:
        kind: K8sNoExternalServices
      validation:
        openAPIV3Schema:
          properties:
            internalCIDRs:
              items:
                type: string
              type: array
  targets:
  - rego: |
      package k8snoexternalservices

      violation[{"msg": msg}] {
        input.review.kind.kind == "Ingress"
        re_match("^(extensions|networking.k8s.io)$", input.review.kind.group)
        msg := "No external service exposure is allowed via ingress"
      }

      violation[{"msg": msg}] {
        input.review.kind.kind == "Gateway"
        input.review.kind.group == "networking.istio.io"
        msg := "Creation of networking.istio.io/Gateway resources is not allowed"
      }

      violation[{"msg": msg}] {
        input.review.kind.kind == "Service"
        input.review.kind.group == ""
        input.review.object.spec.type == "LoadBalancer"
        not input.review.object.metadata.annotations["cloud.google.com/load-balancer-type"] == "Internal"
        msg := "Creating services of type `LoadBalancer` without Internal annotation is not allowed"
      }

      violation[{"msg": msg}] {
        input.review.kind.kind == "Service"
        input.review.kind.group == ""
        ip := input.review.object.spec.externalIPs[_]
        is_external_ip(ip)
        msg := sprintf("Service has an external IP exposed: `%v`", [ip])
      }

      is_external_ip(ip) {
        cidr_membership := [i | cidr := input.parameters.internalCIDRs[_]; i := net.cidr_contains(cidr, ip)]
        not any(cidr_membership)
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Requires all Pods and containers to have a SecurityContext defined at the Pod or container level. Introduced in ACM v1.5.2.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: k8spodsrequiresecuritycontext
spec:
  crd:
    spec:
      names:
        kind: K8sPodsRequireSecurityContext
      validation:
        openAPIV3Schema: {}
  targets:
  - rego: |
      package k8spodsrequiresecuritycontext

      violation[{"msg": msg}] {
        input.review.kind.kind == "Pod"
        container := input.review.object.spec.containers[_]
        has_empty_security_context(container)
        has_empty_security_context(input.review.object.spec)
        msg := "securityContext must be defined for all Pod containers"
      }

      violation[{"msg": msg}] {
        input.review.kind.kind == "Pod"
        initContainer := input.review.object.spec.initContainers[_]
        has_empty_security_context(initContainer)
        has_empty_security_context(input.review.object.spec)
        msg := "securityContext must be defined for all Pod initContainers"
      }

      violation[{"msg": msg}] {
        input.review.kind.kind == "Pod"
        not input.review.object.spec.containers
        not input.review.object.spec.initContainers
        has_empty_security_context(input.review.object.spec)
        msg := "securityContext must be defined for Pod"
      }

      has_empty_security_context(spec) {
        spec.securityContext == {}
      }

      has_empty_security_context(spec) {
        not spec.securityContext
      }

      has_empty_security_context(spec) {
        spec.securityContext == null
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Requires that Roles and ClusterRoles not set resource access to a wildcard ("*") value. Introduced in ACM v1.5.2.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: k8sprohibitrolewildcardaccess
spec:
  crd:
    spec:
      names:
        kind: K8sProhibitRoleWildcardAccess
      validation:
        openAPIV3Schema: {}
  targets:
  - rego: |
      package k8sprohibitrolewildcardaccess

      violation[{"msg": msg}] {
        is_role_or_cluster_role(input.review.kind)
        rule := input.review.object.rules[_]
        rule[field][_] == "*"
        msg := sprintf("<%v> has rule <%v> wildcard match", [input.review.object.metadata.name, field])
      }

      is_role_or_cluster_role(kind) {
        kind.group == "rbac.authorization.k8s.io"
        kinds := {"Role", "ClusterRole"}
        kinds[kind.kind]
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Controls the user and group IDs of the container. Introduced in ACM v1.3.0.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: k8spspallowedusers
spec:
  crd:
    spec:
      names:
        kind: K8sPSPAllowedUsers
      validation:
        openAPIV3Schema:
          properties:
            fsGroup:
              properties:
                ranges:
                  items:
                    properties:
                      max:
                        type: integer
                      min:
                        type: integer
                    type: object
                  type: array
                rule:
                  type: string
              type: object
            runAsGroup:
              properties:
                ranges:
                  items:
                    properties:
                      max:
                        type: integer
                      min:
                        type: integer
                    type: object
                  type: array
                rule:
                  type: string
              type: object
            runAsUser:
              properties:
                ranges:
                  items:
                    properties:
                      max:
                        type: integer
                      min:
                        type: integer
                    type: object
                  type: array
                rule:
                  type: string
              type: object
            supplementalGroups:
              properties:
                ranges:
                  items:
                    properties:
                      max:
                        type: integer
                      min:
                        type: integer
                    type: object
                  type: array
                rule:
                  type: string
              type: object
  targets:
  - rego: |
      package k8spspallowedusers

      violation[{"msg": msg}] {
        fields := ["runAsUser", "runAsGroup", "supplementalGroups", "fsGroup"]
        field := fields[_]
        container := input_containers[_]
        msg := get_type_violation(field, container)
      }

      get_type_violation(field, container) = msg {
        field == "runAsUser"
        params := input.parameters[field]
        msg := get_user_violation(params, container)
      }

      get_type_violation(field, container) = msg {
        field != "runAsUser"
        params := input.parameters[field]
        msg := get_violation(field, params, container)
      }

      # RunAsUser (separate due to "MustRunAsNonRoot")
      get_user_violation(params, container) = msg {
        rule := params.rule
        provided_user := get_field_value("runAsUser", container, input.review)
        not accept_users(rule, provided_user)
        msg := sprintf("Container %v is attempting to run as disallowed user %v. Allowed runAsUser: %v", [container.name, provided_user, params])
      }

      get_user_violation(params, container) = msg {
        not get_field_value("runAsUser", container, input.review)
        params.rule = "MustRunAs"
        msg := sprintf("Container %v is attempting to run without a required securityContext/runAsUser", [container.name])
      }

      get_user_violation(params, container) = msg {
        params.rule = "MustRunAsNonRoot"
        not get_field_value("runAsUser", container, input.review)
        not get_field_value("runAsNonRoot", container, input.review)
        msg := sprintf("Container %v is attempting to run without a required securityContext/runAsNonRoot or securityContext/runAsUser != 0", [container.name])
      }

      accept_users("RunAsAny", provided_user) {true}

      accept_users("MustRunAsNonRoot", provided_user) = res {res := provided_user != 0}

      accept_users("MustRunAs", provided_user) = res  {
        ranges := input.parameters.runAsUser.ranges
        res := is_in_range(provided_user, ranges)
      }

      # Group Options
      get_violation(field, params, container) = msg {
        rule := params.rule
        provided_value := get_field_value(field, container, input.review)
        not is_array(provided_value)
        not accept_value(rule, provided_value, params.ranges)
        msg := sprintf("Container %v is attempting to run as disallowed group %v. Allowed %v: %v", [container.name, provided_value, field, params])
      }
      # SupplementalGroups is array value
      get_violation(field, params, container) = msg {
        rule := params.rule
        array_value := get_field_value(field, container, input.review)
        is_array(array_value)
        provided_value := array_value[_]
        not accept_value(rule, provided_value, params.ranges)
        msg := sprintf("Container %v is attempting to run with disallowed supplementalGroups %v. Allowed %v: %v", [container.name, array_value, field, params])
      }

      get_violation(field, params, container) = msg {
        not get_field_value(field, container, input.review)
        params.rule == "MustRunAs"
        msg := sprintf("Container %v is attempting to run without a required securityContext/%v. Allowed %v: %v", [container.name, field, field, params])
      }

      accept_value("RunAsAny", provided_value, ranges) {true}

      accept_value("MayRunAs", provided_value, ranges) = res { res := is_in_range(provided_value, ranges)}

      accept_value("MustRunAs", provided_value, ranges) = res { res := is_in_range(provided_value, ranges)}


      # If container level is provided, that takes precedence
      get_field_value(field, container, review) = out {
        container_value := get_seccontext_field(field, container)
        out := container_value
      }

      # If no container level exists, use pod level
      get_field_value(field, container, review) = out {
        not has_seccontext_field(field, container)
        review.kind.kind == "Pod"
        pod_value := get_seccontext_field(field, review.object.spec)
        out := pod_value
      }

      # Helper Functions
      is_in_range(val, ranges) = res {
        matching := {1 | val >= ranges[j].min; val <= ranges[j].max}
        res := count(matching) > 0
      }

      has_seccontext_field(field, obj) {
        get_seccontext_field(field, obj)
      }

      has_seccontext_field(field, obj) {
        get_seccontext_field(field, obj) == false
      }

      get_seccontext_field(field, obj) = out {
        out = obj.securityContext[field]
      }

      input_containers[c] {
        c := input.review.object.spec.containers[_]
      }
      input_containers[c] {
        c := input.review.object.spec.initContainers[_]
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Controls restricting escalation to root privileges. Introduced in ACM v1.1.0.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: k8spspallowprivilegeescalationcontainer
spec:
  crd:
    spec:
      names:
        kind: K8sPSPAllowPrivilegeEscalationContainer
  targets:
  - rego: |
      package k8spspallowprivilegeescalationcontainer

      violation[{"msg": msg, "details": {}}] {
          c := input_containers[_]
          input_allow_privilege_escalation(c)
          msg := sprintf("Privilege escalation container is not allowed: %v", [c.name])
      }

      input_allow_privilege_escalation(c) {
          not has_field(c, "securityContext")
      }
      input_allow_privilege_escalation(c) {
          not c.securityContext.allowPrivilegeEscalation == false
      }
      input_containers[c] {
          c := input.review.object.spec.containers[_]
      }
      input_containers[c] {
          c := input.review.object.spec.initContainers[_]
      }
      # has_field returns whether an object has a field
      has_field(object, field) = true {
          object[field]
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Controls the AppArmor profile used by containers. Introduced in ACM v1.3.0.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: k8spspapparmor
spec:
  crd:
    spec:
      names:
        kind: K8sPSPAppArmor
      validation:
        openAPIV3Schema:
          properties:
            allowedProfiles:
              items:
                type: string
              type: array
  targets:
  - rego: |
      package k8spspapparmor

      violation[{"msg": msg, "details": {}}] {
          metadata := input.review.object.metadata
          container := input_containers[_]
          not input_apparmor_allowed(container, metadata)
          msg := sprintf("AppArmor profile is not allowed, pod: %v, container: %v. Allowed profiles: %v", [input.review.object.metadata.name, container.name, input.parameters.allowedProfiles])
      }

      input_apparmor_allowed(container, metadata) {
          metadata.annotations[key] == input.parameters.allowedProfiles[_]
          key == sprintf("container.apparmor.security.beta.kubernetes.io/%v", [container.name])
      }

      input_containers[c] {
          c := input.review.object.spec.containers[_]
      }
      input_containers[c] {
          c := input.review.object.spec.initContainers[_]
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Controls Linux capabilities. Introduced in ACM v1.3.0.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: k8spspcapabilities
spec:
  crd:
    spec:
      names:
        kind: K8sPSPCapabilities
      validation:
        openAPIV3Schema:
          properties:
            allowedCapabilities:
              items:
                type: string
              type: array
            requiredDropCapabilities:
              items:
                type: string
              type: array
  targets:
  - rego: |
      package capabilities

      violation[{"msg": msg}] {
        container := input.review.object.spec.containers[_]
        has_disallowed_capabilities(container)
        msg := sprintf("container <%v> has a disallowed capability. Allowed capabilities are %v", [container.name, get_default(input.parameters, "allowedCapabilities", "NONE")])
      }

      violation[{"msg": msg}] {
        container := input.review.object.spec.containers[_]
        missing_drop_capabilities(container)
        msg := sprintf("container <%v> is not dropping all required capabilities. Container must drop all of %v", [container.name, input.parameters.requiredDropCapabilities])
      }



      violation[{"msg": msg}] {
        container := input.review.object.spec.initContainers[_]
        has_disallowed_capabilities(container)
        msg := sprintf("init container <%v> has a disallowed capability. Allowed capabilities are %v", [container.name, get_default(input.parameters, "allowedCapabilities", "NONE")])
      }

      violation[{"msg": msg}] {
        container := input.review.object.spec.initContainers[_]
        missing_drop_capabilities(container)
        msg := sprintf("init container <%v> is not dropping all required capabilities. Container must drop all of %v", [container.name, input.parameters.requiredDropCapabilities])
      }


      has_disallowed_capabilities(container) {
        allowed := {c | c := input.parameters.allowedCapabilities[_]}
        not allowed["*"]
        capabilities := {c | c := container.securityContext.capabilities.add[_]}
        count(capabilities - allowed) > 0
      }

      missing_drop_capabilities(container) {
        must_drop := {c | c := input.parameters.requiredDropCapabilities[_]}
        dropped := {c | c := container.securityContext.capabilities.drop[_]}
        count(must_drop - dropped) > 0
      }

      get_default(obj, param, _default) = out {
        out = obj[param]
      }

      get_default(obj, param, _default) = out {
        not obj[param]
        not obj[param] == false
        out = _default
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Controls the allowlist of Flexvolume drivers. Introduced in ACM v1.1.0.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: k8spspflexvolumes
spec:
  crd:
    spec:
      names:
        kind: K8sPSPFlexVolumes
      validation:
        openAPIV3Schema:
          properties:
            allowedFlexVolumes:
              items:
                properties:
                  driver:
                    type: string
                type: object
              type: array
  targets:
  - rego: |
      package k8spspflexvolumes

      violation[{"msg": msg, "details": {}}] {
          volume := input_flexvolumes[_]
          not input_flexvolumes_allowed(volume)
          msg := sprintf("FlexVolume %v is not allowed, pod: %v. Allowed drivers: %v", [volume, input.review.object.metadata.name, input.parameters.allowedFlexVolumes])
      }

      input_flexvolumes_allowed(volume) {
          input.parameters.allowedFlexVolumes[_].driver == volume.flexVolume.driver
      }

      input_flexvolumes[v] {
          v := input.review.object.spec.volumes[_]
          has_field(v, "flexVolume")
      }

      # has_field returns whether an object has a field
      has_field(object, field) = true {
          object[field]
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Controls the `sysctl` profile used by containers. Introduced in ACM v1.3.0.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: k8spspforbiddensysctls
spec:
  crd:
    spec:
      names:
        kind: K8sPSPForbiddenSysctls
      validation:
        openAPIV3Schema:
          properties:
            forbiddenSysctls:
              items:
                type: string
              type: array
  targets:
  - rego: |
      package k8spspforbiddensysctls

      violation[{"msg": msg, "details": {}}] {
          sysctl := input.review.object.spec.securityContext.sysctls[_].name
          forbidden_sysctl(sysctl)
          msg := sprintf("The sysctl %v is not allowed, pod: %v. Forbidden sysctls: %v", [sysctl, input.review.object.metadata.name, input.parameters.forbiddenSysctls])
      }

      # * may be used to forbid all sysctls
      forbidden_sysctl(sysctl) {
          input.parameters.forbiddenSysctls[_] == "*"
      }

      forbidden_sysctl(sysctl) {
          input.parameters.forbiddenSysctls[_] == sysctl
      }

      forbidden_sysctl(sysctl) {
          startswith(sysctl, trim(input.parameters.forbiddenSysctls[_], "*"))
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Controls allocating an FSGroup that owns the Pod's volumes. Introduced in ACM v1.1.0.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: k8spspfsgroup
spec:
  crd:
    spec:
      names:
        kind: K8sPSPFSGroup
      validation:
        openAPIV3Schema:
          properties:
            ranges:
              items:
                properties:
                  max:
                    type: integer
                  min:
                    type: integer
                type: object
              type: array
            rule:
              type: string
  targets:
  - rego: |
      package k8spspfsgroup

      violation[{"msg": msg, "details": {}}] {
        spec := input.review.object.spec
        not input_fsGroup_allowed(spec)
        msg := sprintf("The provided pod spec fsGroup is not allowed, pod: %v. Allowed fsGroup: %v", [input.review.object.metadata.name, input.parameters])
      }

      input_fsGroup_allowed(spec) {
        # RunAsAny - No range is required. Allows any fsGroup ID to be specified.
        input.parameters.rule == "RunAsAny"
      }
      input_fsGroup_allowed(spec) {
        # MustRunAs - Validates pod spec fsgroup against all ranges
        input.parameters.rule == "MustRunAs"
        fg := spec.securityContext.fsGroup
        count(input.parameters.ranges) > 0
        range := input.parameters.ranges[_]
        value_within_range(range, fg)
      }
      input_fsGroup_allowed(spec) {
          # MayRunAs - Validates pod spec fsgroup against all ranges or allow pod spec fsgroup to be left unset
          input.parameters.rule == "MayRunAs"
          not has_field(spec, "securityContext")
      }
      input_fsGroup_allowed(spec) {
          # MayRunAs - Validates pod spec fsgroup against all ranges or allow pod spec fsgroup to be left unset
          input.parameters.rule == "MayRunAs"
          not spec.securityContext.fsGroup
      }
      input_fsGroup_allowed(spec) {
        # MayRunAs - Validates pod spec fsgroup against all ranges or allow pod spec fsgroup to be left unset
        input.parameters.rule == "MayRunAs"
        fg := spec.securityContext.fsGroup
        count(input.parameters.ranges) > 0
        range := input.parameters.ranges[_]
        value_within_range(range, fg)
      }
      value_within_range(range, value) {
        range.min <= value
        range.max >= value
      }
      # has_field returns whether an object has a field
      has_field(object, field) = true {
        object[field]
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Controls usage of the host filesystem. Introduced in ACM v1.1.0.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: k8spsphostfilesystem
spec:
  crd:
    spec:
      names:
        kind: K8sPSPHostFilesystem
      validation:
        openAPIV3Schema:
          properties:
            allowedHostPaths:
              items:
                properties:
                  pathPrefix:
                    type: string
                  readOnly:
                    type: boolean
                type: object
              type: array
  targets:
  - rego: |
      package k8spsphostfilesystem

      violation[{"msg": msg, "details": {}}] {
          volume := input_hostpath_volumes[_]
          allowedPaths := get_allowed_paths(input)
          input_hostpath_violation(allowedPaths, volume)
          msg := sprintf("HostPath volume %v is not allowed, pod: %v. Allowed path: %v", [volume, input.review.object.metadata.name, allowedPaths])
      }

      input_hostpath_violation(allowedPaths, volume) {
          # An empty list means all host paths are blocked
          allowedPaths == []
      }
      input_hostpath_violation(allowedPaths, volume) {
          not input_hostpath_allowed(allowedPaths, volume)
      }

      get_allowed_paths(arg) = out {
          not arg.parameters
          out = []
      }
      get_allowed_paths(arg) = out {
          not arg.parameters.allowedHostPaths
          out = []
      }
      get_allowed_paths(arg) = out {
          out = arg.parameters.allowedHostPaths
      }

      input_hostpath_allowed(allowedPaths, volume) {
          allowedHostPath := allowedPaths[_]
          path_matches(allowedHostPath.pathPrefix, volume.hostPath.path)
          not allowedHostPath.readOnly == true
      }

      input_hostpath_allowed(allowedPaths, volume) {
          allowedHostPath := allowedPaths[_]
          path_matches(allowedHostPath.pathPrefix, volume.hostPath.path)
          allowedHostPath.readOnly
          not writeable_input_volume_mounts(volume.name)
      }

      writeable_input_volume_mounts(volume_name) {
          container := input_containers[_]
          mount := container.volumeMounts[_]
          mount.name == volume_name
          not mount.readOnly
      }

      # This allows "/foo", "/foo/", "/foo/bar" etc., but
      # disallows "/fool", "/etc/foo" etc.
      path_matches(prefix, path) {
          a := split(trim(prefix, "/"), "/")
          b := split(trim(path, "/"), "/")
          prefix_matches(a, b)
      }
      prefix_matches(a, b) {
          count(a) <= count(b)
          not any_not_equal_upto(a, b, count(a))
      }

      any_not_equal_upto(a, b, n) {
          a[i] != b[i]
          i < n
      }

      input_hostpath_volumes[v] {
          v := input.review.object.spec.volumes[_]
          has_field(v, "hostPath")
      }

      # has_field returns whether an object has a field
      has_field(object, field) = true {
          object[field]
      }
      input_containers[c] {
          c := input.review.object.spec.containers[_]
      }

      input_containers[c] {
          c := input.review.object.spec.initContainers[_]
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Controls usage of host namespaces. Introduced in ACM v1.1.0.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: k8spsphostnamespace
spec:
  crd:
    spec:
      names:
        kind: K8sPSPHostNamespace
  targets:
  - rego: |
      package k8spsphostnamespace

      violation[{"msg": msg, "details": {}}] {
          input_share_hostnamespace(input.review.object)
          msg := sprintf("Sharing the host namespace is not allowed: %v", [input.review.object.metadata.name])
      }

      input_share_hostnamespace(o) {
          o.spec.hostPID
      }
      input_share_hostnamespace(o) {
          o.spec.hostIPC
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Controls usage of host networking and ports. Introduced in ACM v1.1.0.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: k8spsphostnetworkingports
spec:
  crd:
    spec:
      names:
        kind: K8sPSPHostNetworkingPorts
      validation:
        openAPIV3Schema:
          properties:
            hostNetwork:
              type: boolean
            max:
              type: integer
            min:
              type: integer
  targets:
  - rego: |
      package k8spsphostnetworkingports

      violation[{"msg": msg, "details": {}}] {
        input_share_hostnetwork(input.review.object)
        msg := sprintf("The specified hostNetwork and hostPort are not allowed, pod: %v. Allowed values: %v", [input.review.object.metadata.name, input.parameters])
      }

      input_share_hostnetwork(o) {
        not input.parameters.hostNetwork
        o.spec.hostNetwork
      }

      input_share_hostnetwork(o) {
        hostPort := input_containers[_].ports[_].hostPort
        hostPort < input.parameters.min
      }

      input_share_hostnetwork(o) {
        hostPort := input_containers[_].ports[_].hostPort
        hostPort > input.parameters.max
      }

      input_containers[c] {
        c := input.review.object.spec.containers[_]
      }

      input_containers[c] {
        c := input.review.object.spec.initContainers[_]
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Controls running of privileged containers. Introduced in ACM v1.1.0.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: k8spspprivilegedcontainer
spec:
  crd:
    spec:
      names:
        kind: K8sPSPPrivilegedContainer
  targets:
  - rego: |
      package k8spspprivileged

      violation[{"msg": msg, "details": {}}] {
          c := input_containers[_]
          c.securityContext.privileged
          msg := sprintf("Privileged container is not allowed: %v, securityContext: %v", [c.name, c.securityContext])
      }

      input_containers[c] {
          c := input.review.object.spec.containers[_]
      }

      input_containers[c] {
          c := input.review.object.spec.initContainers[_]
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Controls the allowed `procMount` types for the container. Introduced in ACM v1.1.0.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: k8spspprocmount
spec:
  crd:
    spec:
      names:
        kind: K8sPSPProcMount
      validation:
        openAPIV3Schema:
          properties:
            procMount:
              type: string
  targets:
  - rego: |
      package k8spspprocmount

      violation[{"msg": msg, "details": {}}] {
          c := input_containers[_]
          allowedProcMount := get_allowed_proc_mount(input)
          not input_proc_mount_type_allowed(allowedProcMount, c)
          msg := sprintf("ProcMount type is not allowed, container: %v. Allowed procMount types: %v", [c.name, allowedProcMount])
      }

      input_proc_mount_type_allowed(allowedProcMount, c) {
          allowedProcMount == "default"
          lower(c.securityContext.procMount) == "default"
      }
      input_proc_mount_type_allowed(allowedProcMount, c) {
          allowedProcMount == "unmasked"
      }

      input_containers[c] {
          c := input.review.object.spec.containers[_]
          c.securityContext.procMount
      }
      input_containers[c] {
          c := input.review.object.spec.initContainers[_]
          c.securityContext.procMount
      }

      get_allowed_proc_mount(arg) = out {
          not arg.parameters
          out = "default"
      }
      get_allowed_proc_mount(arg) = out {
          not arg.parameters.procMount
          out = "default"
      }
      get_allowed_proc_mount(arg) = out {
          not valid_proc_mount(arg.parameters.procMount)
          out = "default"
      }
      get_allowed_proc_mount(arg) = out {
          out = lower(arg.parameters.procMount)
      }

      valid_proc_mount(str) {
          lower(str) == "default"
      }
      valid_proc_mount(str) {
          lower(str) == "unmasked"
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Requires the use of a read only root file system. Introduced in ACM v1.1.0.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: k8spspreadonlyrootfilesystem
spec:
  crd:
    spec:
      names:
        kind: K8sPSPReadOnlyRootFilesystem
  targets:
  - rego: |
      package k8spspreadonlyrootfilesystem

      violation[{"msg": msg, "details": {}}] {
          c := input_containers[_]
          input_read_only_root_fs(c)
          msg := sprintf("only read-only root filesystem container is allowed: %v", [c.name])
      }

      input_read_only_root_fs(c) {
          not has_field(c, "securityContext")
      }
      input_read_only_root_fs(c) {
          not c.securityContext.readOnlyRootFilesystem == true
      }

      input_containers[c] {
          c := input.review.object.spec.containers[_]
      }
      input_containers[c] {
          c := input.review.object.spec.initContainers[_]
      }

      # has_field returns whether an object has a field
      has_field(object, field) = true {
          object[field]
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Controls the seccomp profile used by containers. Introduced in ACM v1.3.0.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: k8spspseccomp
spec:
  crd:
    spec:
      names:
        kind: K8sPSPSeccomp
      validation:
        openAPIV3Schema:
          properties:
            allowedProfiles:
              items:
                type: string
              type: array
  targets:
  - rego: |
      package k8spspseccomp

      violation[{"msg": msg, "details": {}}] {
          metadata := input.review.object.metadata
          not input_wildcard_allowed(metadata)
          container := input_containers[_]
          not input_container_allowed(metadata, container)
          msg := sprintf("Seccomp profile is not allowed, pod: %v, container: %v, Allowed profiles: %v", [metadata.name, container.name, input.parameters.allowedProfiles])
      }

      input_wildcard_allowed(metadata) {
          input.parameters.allowedProfiles[_] == "*"
      }

      input_container_allowed(metadata, container) {
          not get_container_profile(metadata, container)
          metadata.annotations["seccomp.security.alpha.kubernetes.io/pod"] == input.parameters.allowedProfiles[_]
      }

      input_container_allowed(metadata, container) {
        profile := get_container_profile(metadata, container)
        profile == input.parameters.allowedProfiles[_]
      }

      get_container_profile(metadata, container) = profile {
        value := metadata.annotations[key]
          startswith(key, "container.seccomp.security.alpha.kubernetes.io/")
          [prefix, name] := split(key, "/")
          name == container.name
          profile = value
      }

      input_containers[c] {
          c := input.review.object.spec.containers[_]
      }
      input_containers[c] {
          c := input.review.object.spec.initContainers[_]
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Controls the SELinux context of the container. Introduced in ACM v1.3.0.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: k8spspselinux
spec:
  crd:
    spec:
      names:
        kind: K8sPSPSELinux
      validation:
        openAPIV3Schema:
          properties:
            allowedSELinuxOptions:
              properties:
                level:
                  type: string
                role:
                  type: string
                type:
                  type: string
                user:
                  type: string
              type: object
  targets:
  - rego: |
      package k8spspselinux

      violation[{"msg": msg, "details": {}}] {
        c := input_security_context[_]
        not input_seLinuxOptions_allowed(c.securityContext.seLinuxOptions)
        msg := sprintf("SELinux option is not allowed, pod: %v. Allowed options: %v", [input.review.object.metadata.name, input.parameters.allowedSELinuxOptions])
      }

      input_seLinuxOptions_allowed(options) {
        input.parameters.allowedSELinuxOptions.level == options.level
      }

      input_seLinuxOptions_allowed(options) {
        input.parameters.allowedSELinuxOptions.role == options.role
      }

      input_seLinuxOptions_allowed(options) {
        input.parameters.allowedSELinuxOptions.type == options.type
      }

      input_seLinuxOptions_allowed(options) {
        input.parameters.allowedSELinuxOptions.user == options.user
      }

      input_security_context[c] {
        c := input.review.object.spec
      }

      input_security_context[c] {
        c := input.review.object.spec.containers[_]
        has_field(c.securityContext, "seLinuxOptions")
      }

      input_security_context[c] {
        c := input.review.object.spec.initContainers[_]
        has_field(c.securityContext, "seLinuxOptions")
      }

      # has_field returns whether an object has a field
      has_field(object, field) {
        object[field]
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Controls the SELinux context of the container. Introduced in ACM v1.5.2.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: k8spspselinuxv2
spec:
  crd:
    spec:
      names:
        kind: K8sPSPSELinuxV2
      validation:
        openAPIV3Schema:
          properties:
            allowedSELinuxOptions:
              items:
                properties:
                  level:
                    type: string
                  role:
                    type: string
                  type:
                    type: string
                  user:
                    type: string
                type: object
              type: array
  targets:
  - rego: |
      package k8spspselinux

      # Disallow top level custom SELinux options
      violation[{"msg": msg, "details": {}}] {
          has_field(input.review.object.spec.securityContext, "seLinuxOptions")
          not input_seLinuxOptions_allowed(input.review.object.spec.securityContext.seLinuxOptions)
          msg := sprintf("SELinux options is not allowed, pod: %v. Allowed options: %v", [input.review.object.metadata.name, input.parameters.allowedSELinuxOptions])
      }
      # Disallow container level custom SELinux options
      violation[{"msg": msg, "details": {}}] {
          c := input_security_context[_]
          has_field(c.securityContext, "seLinuxOptions")
          not input_seLinuxOptions_allowed(c.securityContext.seLinuxOptions)
          msg := sprintf("SELinux options is not allowed, pod: %v, container %v. Allowed options: %v", [input.review.object.metadata.name, c.name, input.parameters.allowedSELinuxOptions])
      }

      input_seLinuxOptions_allowed(options) {
          params := input.parameters.allowedSELinuxOptions[_]
          field_allowed("level", options, params)
          field_allowed("role", options, params)
          field_allowed("type", options, params)
          field_allowed("user", options, params)
      }

      field_allowed(field, options, params) {
          params[field] == options[field]
      }
      field_allowed(field, options, params) {
          not has_field(options, field)
      }

      input_security_context[c] {
          c := input.review.object.spec.containers[_]
          has_field(c.securityContext, "seLinuxOptions")
      }
      input_security_context[c] {
          c := input.review.object.spec.initContainers[_]
          has_field(c.securityContext, "seLinuxOptions")
      }

      # has_field returns whether an object has a field
      has_field(object, field) = true {
          object[field]
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Controls usage of volume types. Introduced in ACM v1.1.0.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: k8spspvolumetypes
spec:
  crd:
    spec:
      names:
        kind: K8sPSPVolumeTypes
      validation:
        openAPIV3Schema:
          properties:
            volumes:
              items:
                type: string
              type: array
  targets:
  - rego: |
      package k8spspvolumetypes

      violation[{"msg": msg, "details": {}}] {
          volume_fields := {x | input.review.object.spec.volumes[_][x]; x != "name"}
          field := volume_fields[_]
          not input_volume_type_allowed(field)
          msg := sprintf("The volume type %v is not allowed, pod: %v. Allowed volume types: %v", [field, input.review.object.metadata.name, input.parameters.volumes])
      }

      # * may be used to allow all volume types
      input_volume_type_allowed(field) {
          input.parameters.volumes[_] == "*"
      }

      input_volume_type_allowed(field) {
          field == input.parameters.volumes[_]
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Requires all resources to contain a specified label with a value matching a provided regular expression.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: k8srequiredlabels
spec:
  crd:
    spec:
      names:
        kind: K8sRequiredLabels
      validation:
        openAPIV3Schema:
          properties:
            labels:
              items:
                properties:
                  allowedRegex:
                    type: string
                  key:
                    type: string
                type: object
              type: array
            message:
              type: string
  targets:
  - rego: |
      package k8srequiredlabels

      get_message(parameters, _default) = msg {
        not parameters.message
        msg := _default
      }

      get_message(parameters, _default) = msg {
        msg := parameters.message
      }

      violation[{"msg": msg, "details": {"missing_labels": missing}}] {
        provided := {label | input.review.object.metadata.labels[label]}
        required := {label | label := input.parameters.labels[_].key}
        missing := required - provided
        count(missing) > 0
        def_msg := sprintf("you must provide labels: %v", [missing])
        msg := get_message(input.parameters, def_msg)
      }

      violation[{"msg": msg}] {
        value := input.review.object.metadata.labels[key]
        expected := input.parameters.labels[_]
        expected.key == key

        # do not match if allowedRegex is not defined, or is an empty string
        expected.allowedRegex != ""
        not re_match(expected.allowedRegex, value)
        def_msg := sprintf("Label <%v: %v> does not satisfy allowed regex: %v", [key, value, expected.allowedRegex])
        msg := get_message(input.parameters, def_msg)
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Requires Pods to have readiness and/or liveness probes.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: k8srequiredprobes
spec:
  crd:
    spec:
      names:
        kind: K8sRequiredProbes
      validation:
        openAPIV3Schema:
          properties:
            probeTypes:
              items:
                type: string
              type: array
            probes:
              items:
                type: string
              type: array
  targets:
  - rego: |
      package k8srequiredprobes

      probe_type_set = probe_types {
        probe_types := {type | type := input.parameters.probeTypes[_]}
      }

      violation[{"msg": msg}] {
        container := input.review.object.spec.containers[_]
        probe := input.parameters.probes[_]
        probe_is_missing(container, probe)
        msg := get_violation_message(container, input.review, probe)
      }

      probe_is_missing(ctr, probe) {
        not ctr[probe]
      }

      probe_is_missing(ctr, probe) {
        probe_field_empty(ctr, probe)
      }

      probe_field_empty(ctr, probe) {
        probe_fields := {field | ctr[probe][field]}
        diff_fields := probe_type_set - probe_fields
        count(diff_fields) == count(probe_type_set)
      }

      get_violation_message(container, review, probe) = msg {
        msg := sprintf("Container <%v> in your <%v> <%v> has no <%v>", [container.name, review.kind.kind, review.object.metadata.name, probe])
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: |-
      Requires that every namespace defined in the cluster has a NetworkPolicy. Introduced in ACM v1.5.2.
      Note: This constraint template is only installed when `enableReferentialRules` is `true`.
  labels:
    policycontroller.configmanagement.gke.io: "true"
    policycontroller.configmanagement.gke.io/referential: "true"
  name: k8srequirenamespacenetworkpolicies
spec:
  crd:
    spec:
      names:
        kind: K8sRequireNamespaceNetworkPolicies
      validation:
        openAPIV3Schema: {}
  targets:
  - rego: |
      package k8srequirenamespacenetworkpolicies

      violation[{"msg": msg}] {
        input.review.kind.kind == "Namespace"
        not namespace_has_networkpolicy(input.review.object.metadata.name)
        msg := sprintf("Namespace <%v> does not have a NetworkPolicy", [input.review.object.metadata.name])
      }

      namespace_has_networkpolicy(ns) {
        np := data.inventory.namespace[ns][_].NetworkPolicy[_]
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Disallows resources from containing a label. Exceptions can be specified by group, kind, namespace, and name. Introduced in ACM v1.6.1.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: k8srestrictlabels
spec:
  crd:
    spec:
      names:
        kind: K8sRestrictLabels
      validation:
        openAPIV3Schema:
          properties:
            exceptions:
              items:
                properties:
                  group:
                    type: string
                  kind:
                    type: string
                  name:
                    type: string
                  namespace:
                    type: string
                type: object
              type: array
            restrictedLabels:
              items:
                type: string
              type: array
  targets:
  - rego: |
      package k8srestrictlabels

      violation[{"msg": msg}] {
        input.review.object.metadata.labels[label]
        restrictedLabel := input.parameters.restrictedLabels[_]
        label == restrictedLabel
        not is_exception(input.parameters, input.review)
        msg := sprintf("<%v> label is restricted", [label])
      }

      is_exception(parameters, review) {
        exception := parameters.exceptions[_]
        review.kind.group == exception.group
        review.kind.kind == exception.kind
        review.object.metadata.namespace == exception.namespace
        review.object.metadata.name == exception.name
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Restricts resources from using namespaces listed under the restrictedNamespaces parameter. Resources can bypass this restriction using a labelSelector. Introduced in ACM v1.5.2.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: k8srestrictnamespaces
spec:
  crd:
    spec:
      names:
        kind: K8sRestrictNamespaces
      validation:
        openAPIV3Schema:
          properties:
            restrictedNamespaces:
              items:
                type: string
              type: array
  targets:
  - rego: |
      package k8srestrictnamespaces

      violation[{"msg": msg}] {
        restricted_ns := input.parameters.restrictedNamespaces[_]
        input.review.object.metadata.namespace == restricted_ns
        msg := sprintf("<%v> namespace is restricted", [restricted_ns])
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Restricts ClusterRoleBindings and RoleBindings from referencing a Role or ClusterRole specified in the constraints. Exceptions can be listed as allowedSubjects in the constraint. Introduced in ACM v1.5.2.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: k8srestrictrolebindings
spec:
  crd:
    spec:
      names:
        kind: K8sRestrictRoleBindings
      validation:
        openAPIV3Schema:
          properties:
            allowedSubjects:
              items:
                properties:
                  apiGroup:
                    type: string
                  kind:
                    type: string
                  name:
                    type: string
                type: object
              type: array
            restrictedRole:
              properties:
                apiGroup:
                  type: string
                kind:
                  type: string
                name:
                  type: string
              type: object
  targets:
  - rego: "package k8srestrictrolebindings\n\nviolation[{\"msg\": msg}] {\n  is_rolebinding_or_cluster_rolebinding(input.review.kind)\n  input.review.object.roleRef.apiGroup == input.parameters.restrictedRole.apiGroup\n  input.review.object.roleRef.kind == input.parameters.restrictedRole.kind\n  input.review.object.roleRef.name == input.parameters.restrictedRole.name\n  has_not_allowed_subject(input.review.object.subjects, input.parameters)\n  msg := sprintf(\"%v is restricted from referencing %v %v\", [input.review.kind.kind, input.parameters.restrictedRole.kind, input.parameters.restrictedRole.name])\n}\n\nis_rolebinding_or_cluster_rolebinding(kind) {\n  kind.group == \"rbac.authorization.k8s.io\"\n  kinds := {\"RoleBinding\", \"ClusterRoleBinding\"}\n  kinds[kind.kind]\n}\n\nhas_not_allowed_subject(subjects, parameters) {\n  subject := subjects[_]\n  not subject_is_allowed(subject, parameters.allowedSubjects)\n}\n\nsubject_is_allowed(subject, allowedSubjects) {\n  allowedSubject := allowedSubjects[_]\n  subject.name == allowedSubject.name\n  subject.kind == allowedSubject.kind\n  api_group_is_equal(subject, allowedSubject)\n}\n\napi_group_is_equal(subject, allowedSubjects) {\n  has_empty_or_undefined_api_group(subject)\n  has_empty_or_undefined_api_group(allowedSubjects)\n}\n\napi_group_is_equal(subject, allowedSubject) {\n subject.apiGroup == allowedSubject.apiGroup\n}\n\nhas_empty_or_undefined_api_group(subject) {\n  not subject.apiGroup\n}\n      \nhas_empty_or_undefined_api_group(subject) {\n subject.apiGroup == \"\"\n} \n"
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Requires all Ingress hosts to be unique.
  labels:
    policycontroller.configmanagement.gke.io: "true"
    policycontroller.configmanagement.gke.io/referential: "true"
  name: k8suniqueingresshost
spec:
  crd:
    spec:
      names:
        kind: K8sUniqueIngressHost
  targets:
  - rego: |
      package k8suniqueingresshost

      identical(obj, review) {
        obj.metadata.namespace == review.object.metadata.namespace
        obj.metadata.name == review.object.metadata.name
      }

      violation[{"msg": msg}] {
        input.review.kind.kind == "Ingress"
        re_match("^(extensions|networking.k8s.io)$", input.review.kind.group)
        host := input.review.object.spec.rules[_].host
        other := data.inventory.namespace[ns][otherapiversion].Ingress[name]
        re_match("^(extensions|networking.k8s.io)/.+$", otherapiversion)
        other.spec.rules[_].host == host
        not identical(other, input.review)
        msg := sprintf("ingress host conflicts with an existing ingress <%v>", [host])
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Requires Services to have unique selectors within a namespace.
  labels:
    policycontroller.configmanagement.gke.io: "true"
    policycontroller.configmanagement.gke.io/referential: "true"
  name: k8suniqueserviceselector
spec:
  crd:
    spec:
      names:
        kind: K8sUniqueServiceSelector
  targets:
  - rego: |
      package k8suniqueserviceselector

      make_apiversion(kind) = apiVersion {
        g := kind.group
        v := kind.version
        g != ""
        apiVersion = sprintf("%v/%v", [g, v])
      }

      make_apiversion(kind) = apiVersion {
        kind.group == ""
        apiVersion = kind.version
      }

      identical(obj, review) {
        obj.metadata.namespace == review.namespace
        obj.metadata.name == review.name
        obj.kind == review.kind.kind
        obj.apiVersion == make_apiversion(review.kind)
      }

      flatten_selector(obj) = flattened {
        selectors := [s | s = concat(":", [key, val]); val = obj.spec.selector[key]]
        flattened := concat(",", sort(selectors))
      }

      violation[{"msg": msg}] {
        input.review.kind.kind == "Service"
        input.review.kind.version == "v1"
        input.review.kind.group == ""
        input_selector := flatten_selector(input.review.object)
        other := data.inventory.namespace[namespace][_][_][name]
        not identical(other, input.review)
        other_selector := flatten_selector(other)
        input_selector == other_selector
        msg := sprintf("same selector as service <%v> in namespace <%v>", [name, namespace])
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Requires that Istio authentication Policy specify peers with `STRICT` mutual TLS. Introduced in ACM v1.4.0.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: policystrictonly
spec:
  crd:
    spec:
      names:
        kind: PolicyStrictOnly
      validation:
        openAPIV3Schema: {}
  targets:
  - rego: |
      package asm.guardrails.policystrictonly

      # VIOLATION spec.peers does not exist
      violation[{"msg": msg}] {
        p := input.review.object

        p.apiVersion == "authentication.istio.io/v1alpha1"
        p.kind == "Policy"

        not p.spec.peers

        msg := "spec.peers does not exist"
      }

      # VIOLATION spec.peers is []
      violation[{"msg": msg}] {
        p := input.review.object

        p.apiVersion == "authentication.istio.io/v1alpha1"
        p.kind == "Policy"

        p.spec.peers == []

        msg := "spec.peers cannot be empty"
      }

      # VIOLATION peer authentication does not set mTLS correctly
      violation[{"msg": msg}] {
        p := input.review.object

        p.apiVersion == "authentication.istio.io/v1alpha1"
        p.kind == "Policy"

        peer := p.spec.peers[_]

        # check for different valid configurations
        not peer.mtls.mode == "STRICT"
        not peer.mtls == {}
        not peer.mtls == null
        not peer.mtls

        msg := "spec.peers does not include STRICT mTLS settings"
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  annotations:
    description: Requires that Istio AuthorizationPolicy rules have source principals set to something other than "*". Introduced in ACM v1.4.0.
  labels:
    policycontroller.configmanagement.gke.io: "true"
  name: sourcenotallauthz
spec:
  crd:
    spec:
      names:
        kind: SourceNotAllAuthz
      validation:
        openAPIV3Schema: {}
  targets:
  - rego: |
      package asm.guardrails.sourcenotallauthz

      # spec.rules[].from[].source.principal does not exist
      violation[{"msg": msg}] {
        p := input.review.object

        p.apiVersion == "security.istio.io/v1beta1"
        p.kind == "AuthorizationPolicy"

        rule := p.spec.rules[_]

        sources := {i | rule.from[_].source[i]}

        not sources.principals

        msg := "source.principals does not exist"
      }

      # spec.rules[].from[].source.principal is set to '*'
      violation[{"msg": msg}] {
        p := input.review.object

        p.apiVersion == "security.istio.io/v1beta1"
        p.kind == "AuthorizationPolicy"

        rule := p.spec.rules[_]

        principals := {v | v := rule.from[_].source.principals[_]}

        principals["*"]

        msg := "source.principals[] cannot be '*'"
      }
    target: admission.k8s.gatekeeper.sh
---
apiVersion: admissionregistration.k8s.io/v1
kind: MutatingWebhookConfiguration
metadata:
  creationTimestamp: null
  labels:
    policycontroller.configmanagement.gke.io: "true"
    policycontroller.configmanagement.gke.io/mutation: "true"
  name: gatekeeper-mutating-webhook-configuration
webhooks:
- admissionReviewVersions:
  - v1
  - v1beta1
  clientConfig:
    caBundle: Cg==
    service:
      name: gatekeeper-mutation-webhook-service
      namespace: gatekeeper-system
      path: /v1/mutate
  failurePolicy: Ignore
  matchPolicy: Exact
  name: mutation.gatekeeper.sh
  namespaceSelector:
    matchExpressions:
    - key: admission.gatekeeper.sh/ignore
      operator: DoesNotExist
  rules:
  - apiGroups:
    - '*'
    apiVersions:
    - '*'
    operations:
    - CREATE
    - UPDATE
    resources:
    - '*'
  sideEffects: None
  timeoutSeconds: 1
---
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  labels:
    gatekeeper.sh/system: "yes"
    policycontroller.configmanagement.gke.io: "true"
  name: gatekeeper-validating-webhook-configuration
webhooks:
- admissionReviewVersions:
  - v1
  - v1beta1
  clientConfig:
    service:
      name: gatekeeper-webhook-service
      namespace: gatekeeper-system
      path: /v1/admit
  failurePolicy: Ignore
  matchPolicy: Exact
  name: validation.gatekeeper.sh
  namespaceSelector:
    matchExpressions:
    - key: admission.gatekeeper.sh/ignore
      operator: DoesNotExist
  rules:
  - apiGroups:
    - '*'
    apiVersions:
    - '*'
    operations:
    - CREATE
    - UPDATE
    resources:
    - '*'
  sideEffects: None
  timeoutSeconds: 3
- admissionReviewVersions:
  - v1
  - v1beta1
  clientConfig:
    service:
      name: gatekeeper-webhook-service
      namespace: gatekeeper-system
      path: /v1/admitlabel
  failurePolicy: Fail
  matchPolicy: Exact
  name: check-ignore-label.gatekeeper.sh
  rules:
  - apiGroups:
    - ""
    apiVersions:
    - '*'
    operations:
    - CREATE
    - UPDATE
    resources:
    - namespaces
  sideEffects: None
  timeoutSeconds: 3
---

# ----- admission-webhook.yaml -----
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  name: anthos-binauthz-admission-controller
  labels:
    binauthz.configmanagement.gke.io: "true"
  annotations:
    version: "1.1"
webhooks:
- name: anthos-imagepolicywebhook.image-policy.k8s.io
  objectSelector:
    matchExpressions:
    - key: "image-policy.k8s.io/break-glass"
      operator: NotIn
      values: ["true"]
    - key: "alpha.image-policy.k8s.io/break-glass"
      operator: NotIn
      values: ["true"]
  rules:
  - apiGroups:
    - ""
    apiVersions:
    - v1
    operations:
    - CREATE
    - UPDATE
    resources:
    - pods
  clientConfig:
    url: this_is_always_set_programaticly
  failurePolicy: Ignore
  sideEffects: None
  admissionReviewVersions: ["v1", "v1beta1"]
---

# ----- rg_manifest.yaml -----
apiVersion: v1
kind: Namespace
metadata:
  labels:
    configmanagement.gke.io/arch: "csmr"
    control-plane: controller-manager
  name: resource-group-system
---
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  annotations:
    controller-gen.kubebuilder.io/version: v0.2.5
  labels:
    configmanagement.gke.io/arch: "csmr"
  name: resourcegroups.kpt.dev
spec:
  group: kpt.dev
  names:
    kind: ResourceGroup
    listKind: ResourceGroupList
    plural: resourcegroups
    singular: resourcegroup
  preserveUnknownFields: false
  scope: Namespaced
  versions:
  - additionalPrinterColumns:
    - jsonPath: .status.conditions[0].status
      name: Reconciling
      type: string
    - jsonPath: .status.conditions[1].status
      name: Stalled
      type: string
    - jsonPath: .metadata.creationTimestamp
      name: Age
      type: date
    name: v1alpha1
    schema:
      openAPIV3Schema:
        description: ResourceGroup is the Schema for the resourcegroups API
        properties:
          apiVersion:
            description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
            type: string
          kind:
            description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
            type: string
          metadata:
            type: object
          spec:
            description: spec defines the desired state of ResourceGroup
            properties:
              descriptor:
                description: descriptor regroups the information and metadata about a resource group
                properties:
                  description:
                    description: description is a brief description of a group of resources
                    type: string
                  links:
                    description: links are a list of descriptive URLs intended to be used to surface additional information
                    items:
                      properties:
                        description:
                          description: description explains the purpose of the link
                          type: string
                        url:
                          description: url is the URL of the link
                          type: string
                      required:
                      - description
                      - url
                      type: object
                    type: array
                  revision:
                    description: revision is an optional revision for a group of resources
                    type: string
                  type:
                    description: type can contain prefix, such as Application/WordPress or Service/Spanner
                    type: string
                type: object
              resources:
                description: resources contains a list of resources that form the resource group
                items:
                  description: each item organizes and stores the identifying information for an object. This struct (as a string) is stored in a grouping object to keep track of sets of applied objects.
                  properties:
                    group:
                      type: string
                    kind:
                      type: string
                    name:
                      type: string
                    namespace:
                      type: string
                  required:
                  - group
                  - kind
                  - name
                  - namespace
                  type: object
                type: array
              subgroups:
                description: subgroups contains a list of sub groups that the current group includes.
                items:
                  description: Each item organizes and stores the identifying information for a ResourceGroup object. It includes name and namespace.
                  properties:
                    name:
                      type: string
                    namespace:
                      type: string
                  required:
                  - name
                  - namespace
                  type: object
                type: array
            type: object
          status:
            description: status defines the observed state of ResourceGroup
            properties:
              conditions:
                description: conditions lists the conditions of the current status for the group
                items:
                  properties:
                    lastTransitionTime:
                      description: last time the condition transit from one status to another
                      format: date-time
                      type: string
                    message:
                      description: human-readable message indicating details about last transition
                      type: string
                    reason:
                      description: one-word CamelCase reason for the conditions last transition
                      type: string
                    status:
                      description: status of the condition
                      type: string
                    type:
                      description: type of the condition
                      type: string
                  required:
                  - status
                  - type
                  type: object
                type: array
              observedGeneration:
                description: observedGeneration is the most recent generation observed. It corresponds to the Object's generation, which is updated on mutation by the API Server. Everytime the controller does a successful reconcile, it sets observedGeneration to match ResourceGroup.metadata.generation.
                format: int64
                type: integer
              resourceStatuses:
                description: resourceStatuses lists the status for each resource in the group
                items:
                  description: each item contains the status of a given resource uniquely identified by its group, kind, name and namespace.
                  properties:
                    conditions:
                      items:
                        properties:
                          lastTransitionTime:
                            description: last time the condition transit from one status to another
                            format: date-time
                            type: string
                          message:
                            description: human-readable message indicating details about last transition
                            type: string
                          reason:
                            description: one-word CamelCase reason for the conditions last transition
                            type: string
                          status:
                            description: status of the condition
                            type: string
                          type:
                            description: type of the condition
                            type: string
                        required:
                        - status
                        - type
                        type: object
                      type: array
                    group:
                      type: string
                    kind:
                      type: string
                    name:
                      type: string
                    namespace:
                      type: string
                    status:
                      description: Status describes the status of a resource
                      type: string
                  required:
                  - group
                  - kind
                  - name
                  - namespace
                  - status
                  type: object
                type: array
              subgroupStatuses:
                description: subgroupStatuses lists the status for each subgroup.
                items:
                  description: Each item contains the status of a given group uniquely identified by its name and namespace.
                  properties:
                    conditions:
                      items:
                        properties:
                          lastTransitionTime:
                            description: last time the condition transit from one status to another
                            format: date-time
                            type: string
                          message:
                            description: human-readable message indicating details about last transition
                            type: string
                          reason:
                            description: one-word CamelCase reason for the conditions last transition
                            type: string
                          status:
                            description: status of the condition
                            type: string
                          type:
                            description: type of the condition
                            type: string
                        required:
                        - status
                        - type
                        type: object
                      type: array
                    name:
                      type: string
                    namespace:
                      type: string
                    status:
                      description: Status describes the status of a resource
                      type: string
                  required:
                  - name
                  - namespace
                  - status
                  type: object
                type: array
            required:
            - observedGeneration
            type: object
        type: object
    served: true
    storage: true
    subresources:
      status: {}
status:
  acceptedNames:
    kind: ""
    plural: ""
  conditions: []
  storedVersions: []
---
apiVersion: v1
kind: ServiceAccount
metadata:
  labels:
    configmanagement.gke.io/arch: "csmr"
  name: resource-group-sa
  namespace: resource-group-system
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  labels:
    configmanagement.gke.io/arch: "csmr"
  name: resource-group-leader-election-role
  namespace: resource-group-system
rules:
- apiGroups:
  - ""
  resources:
  - configmaps
  verbs:
  - get
  - list
  - watch
  - create
  - update
  - patch
  - delete
- apiGroups:
  - ""
  resources:
  - configmaps/status
  verbs:
  - get
  - update
  - patch
- apiGroups:
  - ""
  resources:
  - events
  verbs:
  - create
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  creationTimestamp: null
  labels:
    configmanagement.gke.io/arch: "csmr"
  name: resource-group-manager-role
rules:
- apiGroups:
  - '*'
  resources:
  - '*'
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - coordination.k8s.io
  resources:
  - leases
  verbs:
  - '*'
- apiGroups:
  - kpt.dev
  resources:
  - resourcegroups
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - kpt.dev
  resources:
  - resourcegroups/status
  verbs:
  - get
  - patch
  - update
- apiGroups:
  - policy
  resourceNames:
  - acm-psp
  resources:
  - podsecuritypolicies
  verbs:
  - use
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  labels:
    configmanagement.gke.io/arch: "csmr"
  name: resource-group-metrics-reader
rules:
- nonResourceURLs:
  - /metrics
  verbs:
  - get
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  labels:
    configmanagement.gke.io/arch: "csmr"
  name: resource-group-proxy-role
rules:
- apiGroups:
  - authentication.k8s.io
  resources:
  - tokenreviews
  verbs:
  - create
- apiGroups:
  - authorization.k8s.io
  resources:
  - subjectaccessreviews
  verbs:
  - create
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  labels:
    configmanagement.gke.io/arch: "csmr"
  name: resource-group-leader-election-rolebinding
  namespace: resource-group-system
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: resource-group-leader-election-role
subjects:
- kind: ServiceAccount
  name: resource-group-sa
  namespace: resource-group-system
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  labels:
    configmanagement.gke.io/arch: "csmr"
  name: resource-group-manager-rolebinding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: resource-group-manager-role
subjects:
- kind: ServiceAccount
  name: resource-group-sa
  namespace: resource-group-system
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  labels:
    configmanagement.gke.io/arch: "csmr"
  name: resource-group-proxy-rolebinding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: resource-group-proxy-role
subjects:
- kind: ServiceAccount
  name: resource-group-sa
  namespace: resource-group-system
---
apiVersion: v1
kind: Service
metadata:
  labels:
    configmanagement.gke.io/arch: "csmr"
    control-plane: controller-manager
  name: resource-group-controller-manager-metrics-service
  namespace: resource-group-system
spec:
  ports:
  - name: https
    port: 8443
    targetPort: https
  selector:
    configmanagement.gke.io/arch: "csmr"
    control-plane: controller-manager
---
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    configmanagement.gke.io/arch: "csmr"
    control-plane: controller-manager
  name: resource-group-controller-manager
  namespace: resource-group-system
spec:
  replicas: 1
  selector:
    matchLabels:
      configmanagement.gke.io/arch: "csmr"
      control-plane: controller-manager
  template:
    metadata:
      labels:
        configmanagement.gke.io/arch: "csmr"
        control-plane: controller-manager
    spec:
      containers:
      - args:
        - --secure-listen-address=0.0.0.0:8443
        - --upstream=http://127.0.0.1:8080/
        - --logtostderr=true
        - --v=10
        image: gcr.io/config-management-release/kube-rbac-proxy:v0.5.0
        name: kube-rbac-proxy
        ports:
        - containerPort: 8443
          name: https
        securityContext:
          runAsNonRoot: true
          runAsUser: 1000
      - args:
        - --metrics-addr=127.0.0.1:8080
        - --enable-leader-election
        command:
        - /manager
        image: gcr.io/config-management-release/resource-group-controller:v0.7.4
        imagePullPolicy: Always
        name: manager
        resources:
          limits:
            cpu: 300m
            memory: 500Mi
          requests:
            cpu: 100m
            memory: 50Mi
        securityContext:
          runAsNonRoot: true
          runAsUser: 1000
      serviceAccountName: resource-group-sa
      terminationGracePeriodSeconds: 10
---

# ----- hnc-manager.yaml -----
apiVersion: v1
kind: Namespace
metadata:
  labels:
    control-plane: controller-manager
    hierarchycontroller.configmanagement.gke.io: "true"
    hnc.x-k8s.io/excluded-namespace: "true"
  name: hnc-system
---
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  annotations:
    controller-gen.kubebuilder.io/version: v0.5.0
  creationTimestamp: null
  labels:
    hierarchycontroller.configmanagement.gke.io: "true"
  name: hierarchyconfigurations.hnc.x-k8s.io
spec:
  conversion:
    strategy: Webhook
    webhook:
      clientConfig:
        service:
          name: webhook-service
          namespace: system
          path: /convert
      conversionReviewVersions:
      - v1
      - v1beta1
  group: hnc.x-k8s.io
  names:
    kind: HierarchyConfiguration
    listKind: HierarchyConfigurationList
    plural: hierarchyconfigurations
    singular: hierarchyconfiguration
  preserveUnknownFields: false
  scope: Namespaced
  versions:
  - name: v1alpha2
    schema:
      openAPIV3Schema:
        description: Hierarchy is the Schema for the hierarchies API
        properties:
          apiVersion:
            description: 'APIVersion defines the versioned schema of this representation
              of an object. Servers should convert recognized schemas to the latest
              internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
            type: string
          kind:
            description: 'Kind is a string value representing the REST resource this
              object represents. Servers may infer this from the endpoint the client
              submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
            type: string
          metadata:
            properties:
              name:
                enum:
                - hierarchy
                type: string
            type: object
          spec:
            description: HierarchySpec defines the desired state of Hierarchy
            properties:
              allowCascadingDeletion:
                description: AllowCascadingDeletion indicates if the subnamespaces
                  of this namespace are allowed to cascading delete.
                type: boolean
              parent:
                description: Parent indicates the parent of this namespace, if any.
                type: string
            type: object
          status:
            description: HierarchyStatus defines the observed state of Hierarchy
            properties:
              children:
                description: Children indicates the direct children of this namespace,
                  if any.
                items:
                  type: string
                type: array
              conditions:
                description: Conditions describes the errors, if any.
                items:
                  description: "Condition contains details for one aspect of the current
                    state of this API Resource. --- This struct is intended for direct
                    use as an array at the field path .status.conditions.  For example,
                    type FooStatus struct{     // Represents the observations of a
                    foo's current state.     // Known .status.conditions.type are:
                    \"Available\", \"Progressing\", and \"Degraded\"     // +patchMergeKey=type
                    \    // +patchStrategy=merge     // +listType=map     // +listMapKey=type
                    \    Conditions []metav1.Condition `json:\"conditions,omitempty\"
                    patchStrategy:\"merge\" patchMergeKey:\"type\" protobuf:\"bytes,1,rep,name=conditions\"`
                    \n     // other fields }"
                  properties:
                    lastTransitionTime:
                      description: lastTransitionTime is the last time the condition
                        transitioned from one status to another. This should be when
                        the underlying condition changed.  If that is not known, then
                        using the time when the API field changed is acceptable.
                      format: date-time
                      type: string
                    message:
                      description: message is a human readable message indicating
                        details about the transition. This may be an empty string.
                      maxLength: 32768
                      type: string
                    observedGeneration:
                      description: observedGeneration represents the .metadata.generation
                        that the condition was set based upon. For instance, if .metadata.generation
                        is currently 12, but the .status.conditions[x].observedGeneration
                        is 9, the condition is out of date with respect to the current
                        state of the instance.
                      format: int64
                      minimum: 0
                      type: integer
                    reason:
                      description: reason contains a programmatic identifier indicating
                        the reason for the condition's last transition. Producers
                        of specific condition types may define expected values and
                        meanings for this field, and whether the values are considered
                        a guaranteed API. The value should be a CamelCase string.
                        This field may not be empty.
                      maxLength: 1024
                      minLength: 1
                      pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$
                      type: string
                    status:
                      description: status of the condition, one of True, False, Unknown.
                      enum:
                      - "True"
                      - "False"
                      - Unknown
                      type: string
                    type:
                      description: type of condition in CamelCase or in foo.example.com/CamelCase.
                        --- Many .condition.type values are consistent across resources
                        like Available, but because arbitrary conditions can be useful
                        (see .node.status.conditions), the ability to deconflict is
                        important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
                      maxLength: 316
                      pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$
                      type: string
                  required:
                  - lastTransitionTime
                  - message
                  - reason
                  - status
                  - type
                  type: object
                type: array
            type: object
        type: object
    served: true
    storage: true
status:
  acceptedNames:
    kind: ""
    plural: ""
  conditions: []
  storedVersions: []
---
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  annotations:
    controller-gen.kubebuilder.io/version: v0.5.0
  creationTimestamp: null
  labels:
    hierarchycontroller.configmanagement.gke.io: "true"
  name: hncconfigurations.hnc.x-k8s.io
spec:
  conversion:
    strategy: Webhook
    webhook:
      clientConfig:
        service:
          name: webhook-service
          namespace: system
          path: /convert
      conversionReviewVersions:
      - v1
      - v1beta1
  group: hnc.x-k8s.io
  names:
    kind: HNCConfiguration
    listKind: HNCConfigurationList
    plural: hncconfigurations
    singular: hncconfiguration
  preserveUnknownFields: false
  scope: Cluster
  versions:
  - name: v1alpha2
    schema:
      openAPIV3Schema:
        description: HNCConfiguration is a cluster-wide configuration for HNC as a
          whole. See details in http://bit.ly/hnc-type-configuration
        properties:
          apiVersion:
            description: 'APIVersion defines the versioned schema of this representation
              of an object. Servers should convert recognized schemas to the latest
              internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
            type: string
          kind:
            description: 'Kind is a string value representing the REST resource this
              object represents. Servers may infer this from the endpoint the client
              submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
            type: string
          metadata:
            properties:
              name:
                enum:
                - config
                type: string
            type: object
          spec:
            description: HNCConfigurationSpec defines the desired state of HNC configuration.
            properties:
              resources:
                description: Resources defines the cluster-wide settings for resource
                  synchronization. Note that 'roles' and 'rolebindings' are pre-configured
                  by HNC with 'Propagate' mode and are omitted in the spec. Any configuration
                  of 'roles' or 'rolebindings' are not allowed. To learn more, see
                  https://github.com/kubernetes-sigs/multi-tenancy/blob/master/incubator/hnc/docs/user-guide/how-to.md#admin-types
                items:
                  description: ResourceSpec defines the desired synchronization state
                    of a specific resource.
                  properties:
                    group:
                      description: Group of the resource defined below. This is used
                        to unambiguously identify the resource. It may be omitted
                        for core resources (e.g. "secrets").
                      type: string
                    mode:
                      description: Synchronization mode of the kind. If the field
                        is empty, it will be treated as "Propagate".
                      enum:
                      - Propagate
                      - Ignore
                      - Remove
                      type: string
                    resource:
                      description: Resource to be configured.
                      type: string
                  required:
                  - resource
                  type: object
                type: array
            type: object
          status:
            description: HNCConfigurationStatus defines the observed state of HNC
              configuration.
            properties:
              conditions:
                description: Conditions describes the errors, if any. If there are
                  any conditions with "ActivitiesHalted" reason, this means that HNC
                  cannot function in the affected namespaces. The HierarchyConfiguration
                  object in each of the affected namespaces will have more information.
                  To learn more about conditions, see https://github.com/kubernetes-sigs/multi-tenancy/blob/master/incubator/hnc/docs/user-guide/concepts.md#admin-conditions.
                items:
                  description: "Condition contains details for one aspect of the current
                    state of this API Resource. --- This struct is intended for direct
                    use as an array at the field path .status.conditions.  For example,
                    type FooStatus struct{     // Represents the observations of a
                    foo's current state.     // Known .status.conditions.type are:
                    \"Available\", \"Progressing\", and \"Degraded\"     // +patchMergeKey=type
                    \    // +patchStrategy=merge     // +listType=map     // +listMapKey=type
                    \    Conditions []metav1.Condition `json:\"conditions,omitempty\"
                    patchStrategy:\"merge\" patchMergeKey:\"type\" protobuf:\"bytes,1,rep,name=conditions\"`
                    \n     // other fields }"
                  properties:
                    lastTransitionTime:
                      description: lastTransitionTime is the last time the condition
                        transitioned from one status to another. This should be when
                        the underlying condition changed.  If that is not known, then
                        using the time when the API field changed is acceptable.
                      format: date-time
                      type: string
                    message:
                      description: message is a human readable message indicating
                        details about the transition. This may be an empty string.
                      maxLength: 32768
                      type: string
                    observedGeneration:
                      description: observedGeneration represents the .metadata.generation
                        that the condition was set based upon. For instance, if .metadata.generation
                        is currently 12, but the .status.conditions[x].observedGeneration
                        is 9, the condition is out of date with respect to the current
                        state of the instance.
                      format: int64
                      minimum: 0
                      type: integer
                    reason:
                      description: reason contains a programmatic identifier indicating
                        the reason for the condition's last transition. Producers
                        of specific condition types may define expected values and
                        meanings for this field, and whether the values are considered
                        a guaranteed API. The value should be a CamelCase string.
                        This field may not be empty.
                      maxLength: 1024
                      minLength: 1
                      pattern: ^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$
                      type: string
                    status:
                      description: status of the condition, one of True, False, Unknown.
                      enum:
                      - "True"
                      - "False"
                      - Unknown
                      type: string
                    type:
                      description: type of condition in CamelCase or in foo.example.com/CamelCase.
                        --- Many .condition.type values are consistent across resources
                        like Available, but because arbitrary conditions can be useful
                        (see .node.status.conditions), the ability to deconflict is
                        important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
                      maxLength: 316
                      pattern: ^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$
                      type: string
                  required:
                  - lastTransitionTime
                  - message
                  - reason
                  - status
                  - type
                  type: object
                type: array
              resources:
                description: Resources indicates the observed synchronization states
                  of the resources.
                items:
                  description: ResourceStatus defines the actual synchronization state
                    of a specific resource.
                  properties:
                    group:
                      description: The API group of the resource being synchronized.
                      type: string
                    mode:
                      description: Mode describes the synchronization mode of the
                        kind. Typically, it will be the same as the mode in the spec,
                        except when the reconciler has fallen behind or for resources
                        with an enforced default synchronization mode, such as RBAC
                        objects.
                      type: string
                    numPropagatedObjects:
                      description: Tracks the number of objects that are being propagated
                        to descendant namespaces. The propagated objects are created
                        by HNC.
                      minimum: 0
                      type: integer
                    numSourceObjects:
                      description: Tracks the number of objects that are created by
                        users.
                      minimum: 0
                      type: integer
                    resource:
                      description: The resource being synchronized.
                      type: string
                    version:
                      description: The API version used by HNC when propagating this
                        resource.
                      type: string
                  required:
                  - group
                  - resource
                  - version
                  type: object
                type: array
            type: object
        type: object
    served: true
    storage: true
status:
  acceptedNames:
    kind: ""
    plural: ""
  conditions: []
  storedVersions: []
---
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  annotations:
    controller-gen.kubebuilder.io/version: v0.5.0
  creationTimestamp: null
  labels:
    hierarchycontroller.configmanagement.gke.io: "true"
  name: subnamespaceanchors.hnc.x-k8s.io
spec:
  conversion:
    strategy: Webhook
    webhook:
      clientConfig:
        service:
          name: webhook-service
          namespace: system
          path: /convert
      conversionReviewVersions:
      - v1
      - v1beta1
  group: hnc.x-k8s.io
  names:
    kind: SubnamespaceAnchor
    listKind: SubnamespaceAnchorList
    plural: subnamespaceanchors
    shortNames:
    - subns
    singular: subnamespaceanchor
  preserveUnknownFields: false
  scope: Namespaced
  versions:
  - name: v1alpha2
    schema:
      openAPIV3Schema:
        description: SubnamespaceAnchor is the Schema for the subnamespace API. See
          details at http://bit.ly/hnc-self-serve-ux.
        properties:
          apiVersion:
            description: 'APIVersion defines the versioned schema of this representation
              of an object. Servers should convert recognized schemas to the latest
              internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
            type: string
          kind:
            description: 'Kind is a string value representing the REST resource this
              object represents. Servers may infer this from the endpoint the client
              submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
            type: string
          metadata:
            type: object
          status:
            description: SubnamespaceAnchorStatus defines the observed state of SubnamespaceAnchor.
            properties:
              status:
                description: "Describes the state of the subnamespace anchor. \n Currently,
                  the supported values are: \n - \"Missing\": the subnamespace has
                  not been created yet. This should be the default state when the
                  anchor is just created. \n - \"Ok\": the subnamespace exists. This
                  is the only good state of the anchor. \n - \"Conflict\": a namespace
                  of the same name already exists. The admission controller will attempt
                  to prevent this. \n - \"Forbidden\": the anchor was created in a
                  namespace that doesn't allow children, such as kube-system or hnc-system.
                  The admission controller will attempt to prevent this."
                type: string
            type: object
        type: object
    served: true
    storage: true
status:
  acceptedNames:
    kind: ""
    plural: ""
  conditions: []
  storedVersions: []
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  labels:
    hierarchycontroller.configmanagement.gke.io: "true"
  name: hnc-leader-election-role
  namespace: hnc-system
rules:
- apiGroups:
  - ""
  resources:
  - configmaps
  verbs:
  - get
  - list
  - watch
  - create
  - update
  - patch
  - delete
- apiGroups:
  - ""
  resources:
  - configmaps/status
  verbs:
  - get
  - update
  - patch
- apiGroups:
  - ""
  resources:
  - events
  verbs:
  - create
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  labels:
    hierarchycontroller.configmanagement.gke.io: "true"
    rbac.authorization.k8s.io/aggregate-to-admin: "true"
  name: hnc-admin-role
rules:
- apiGroups:
  - hnc.x-k8s.io
  resources:
  - '*'
  verbs:
  - '*'
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  creationTimestamp: null
  labels:
    hierarchycontroller.configmanagement.gke.io: "true"
  name: hnc-manager-role
rules:
- apiGroups:
  - '*'
  resources:
  - '*'
  verbs:
  - '*'
- apiGroups:
  - ""
  resources:
  - namespaces
  verbs:
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - hnc.x-k8s.io
  resources:
  - hierarchies
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - hnc.x-k8s.io
  resources:
  - hierarchies/status
  verbs:
  - get
  - patch
  - update
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  labels:
    hierarchycontroller.configmanagement.gke.io: "true"
  name: hnc-proxy-role
rules:
- apiGroups:
  - authentication.k8s.io
  resources:
  - tokenreviews
  verbs:
  - create
- apiGroups:
  - authorization.k8s.io
  resources:
  - subjectaccessreviews
  verbs:
  - create
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  labels:
    hierarchycontroller.configmanagement.gke.io: "true"
  name: hnc-leader-election-rolebinding
  namespace: hnc-system
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: hnc-leader-election-role
subjects:
- kind: ServiceAccount
  name: default
  namespace: hnc-system
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  labels:
    hierarchycontroller.configmanagement.gke.io: "true"
  name: hnc-manager-rolebinding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: hnc-manager-role
subjects:
- kind: ServiceAccount
  name: default
  namespace: hnc-system
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  labels:
    hierarchycontroller.configmanagement.gke.io: "true"
  name: hnc-proxy-rolebinding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: hnc-proxy-role
subjects:
- kind: ServiceAccount
  name: default
  namespace: hnc-system
---
apiVersion: v1
kind: Secret
metadata:
  labels:
    hierarchycontroller.configmanagement.gke.io: "true"
  name: hnc-webhook-server-cert
  namespace: hnc-system
---
apiVersion: v1
kind: Service
metadata:
  annotations:
    prometheus.io/port: "8443"
    prometheus.io/scheme: https
    prometheus.io/scrape: "true"
  labels:
    control-plane: controller-manager
    hierarchycontroller.configmanagement.gke.io: "true"
  name: hnc-controller-manager-metrics-service
  namespace: hnc-system
spec:
  ports:
  - name: https
    port: 8443
    targetPort: https
  selector:
    control-plane: controller-manager
    hierarchycontroller.configmanagement.gke.io: "true"
---
apiVersion: v1
kind: Service
metadata:
  labels:
    hierarchycontroller.configmanagement.gke.io: "true"
  name: hnc-webhook-service
  namespace: hnc-system
spec:
  ports:
  - port: 443
    targetPort: 10250
  selector:
    control-plane: controller-manager
    hierarchycontroller.configmanagement.gke.io: "true"
---
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    control-plane: controller-manager
    hierarchycontroller.configmanagement.gke.io: "true"
  name: hnc-controller-manager
  namespace: hnc-system
spec:
  replicas: 1
  selector:
    matchLabels:
      control-plane: controller-manager
      hierarchycontroller.configmanagement.gke.io: "true"
  template:
    metadata:
      annotations:
        prometheus.io/scrape: "true"
      labels:
        control-plane: controller-manager
        hierarchycontroller.configmanagement.gke.io: "true"
        monitored: "true"
    spec:
      containers:
      - args:
        - --webhook-server-port=10250
        - --metrics-addr=:8080
        - --max-reconciles=10
        - --apiserver-qps-throttle=50
        - --enable-internal-cert-management
        - --cert-restart-on-secret-refresh
        - --excluded-namespace=kube-system
        - --excluded-namespace=kube-public
        - --excluded-namespace=hnc-system
        - --excluded-namespace=kube-node-lease
        - --unpropagated-annotation=configmanagement.gke.io/declared-config
        - --unpropagated-annotation=configmanagement.gke.io/managed
        - --unpropagated-annotation=configmanagement.gke.io/token
        - --unpropagated-annotation=configmanagement.gke.io/cluster-selector
        - --unpropagated-annotation=configmanagement.gke.io/cluster-name
        - --unpropagated-annotation=configmanagement.gke.io/source-path
        - --unpropagated-annotation=configsync.gke.io/cluster-name-selector
        - --unpropagated-annotation=configsync.gke.io/declared-fields
        - --unpropagated-annotation=configsync.gke.io/resource-id
        command:
        - /manager
        image: gcr.io/config-management-release/hnc-manager:hnc-v0.8.0-hc.3
        name: manager
        ports:
        - containerPort: 10250
          name: webhook-server
          protocol: TCP
        - containerPort: 8080
          name: metrics
          protocol: TCP
        resources:
          limits:
            cpu: 100m
            memory: 300Mi
          requests:
            cpu: 100m
            memory: 150Mi
        volumeMounts:
        - mountPath: /tmp/k8s-webhook-server/serving-certs
          name: cert
          readOnly: true
      securityContext:
        fsGroup: 2000
        runAsNonRoot: true
        runAsUser: 1000
      terminationGracePeriodSeconds: 10
      volumes:
      - name: cert
        secret:
          defaultMode: 420
          secretName: hnc-webhook-server-cert
---
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  creationTimestamp: null
  labels:
    hierarchycontroller.configmanagement.gke.io: "true"
  name: hnc-validating-webhook-configuration
webhooks:
- admissionReviewVersions:
  - v1
  - v1beta1
  clientConfig:
    service:
      name: hnc-webhook-service
      namespace: hnc-system
      path: /validate-objects
  failurePolicy: Ignore
  name: objects.hnc.x-k8s.io
  namespaceSelector:
    matchExpressions:
    - key: hnc.x-k8s.io/excluded-namespace
      operator: DoesNotExist
  rules:
  - apiGroups:
    - '*'
    apiVersions:
    - '*'
    operations:
    - CREATE
    - UPDATE
    - DELETE
    resources:
    - '*'
    scope: Namespaced
  sideEffects: None
  timeoutSeconds: 2
- admissionReviewVersions:
  - v1
  - v1beta1
  clientConfig:
    service:
      name: hnc-webhook-service
      namespace: hnc-system
      path: /validate-hnc-x-k8s-io-v1alpha2-subnamespaceanchors
  failurePolicy: Fail
  name: subnamespaceanchors.hnc.x-k8s.io
  rules:
  - apiGroups:
    - hnc.x-k8s.io
    apiVersions:
    - v1alpha2
    operations:
    - CREATE
    - DELETE
    resources:
    - subnamespaceanchors
  sideEffects: None
- admissionReviewVersions:
  - v1
  - v1beta1
  clientConfig:
    service:
      name: hnc-webhook-service
      namespace: hnc-system
      path: /validate-hnc-x-k8s-io-v1alpha2-hierarchyconfigurations
  failurePolicy: Fail
  name: hierarchyconfigurations.hnc.x-k8s.io
  rules:
  - apiGroups:
    - hnc.x-k8s.io
    apiVersions:
    - v1alpha2
    operations:
    - CREATE
    - UPDATE
    resources:
    - hierarchyconfigurations
  sideEffects: None
- admissionReviewVersions:
  - v1
  - v1beta1
  clientConfig:
    service:
      name: hnc-webhook-service
      namespace: hnc-system
      path: /validate-hnc-x-k8s-io-v1alpha2-hncconfigurations
  failurePolicy: Fail
  name: hncconfigurations.hnc.x-k8s.io
  rules:
  - apiGroups:
    - hnc.x-k8s.io
    apiVersions:
    - v1alpha2
    operations:
    - CREATE
    - UPDATE
    - DELETE
    resources:
    - hncconfigurations
  sideEffects: None
- admissionReviewVersions:
  - v1
  - v1beta1
  clientConfig:
    service:
      name: hnc-webhook-service
      namespace: hnc-system
      path: /validate-v1-namespace
  failurePolicy: Fail
  name: namespaces.hnc.x-k8s.io
  rules:
  - apiGroups:
    - ""
    apiVersions:
    - v1
    operations:
    - DELETE
    - CREATE
    - UPDATE
    resources:
    - namespaces
  sideEffects: None
---

# ----- gke-hc-manager.yaml -----
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  annotations:
    controller-gen.kubebuilder.io/version: v0.5.0
  creationTimestamp: null
  labels:
    extensions.hierarchycontroller.configmanagement.gke.io: "true"
    hierarchycontroller.configmanagement.gke.io: "true"
  name: hierarchicalresourcequotas.hierarchycontroller.configmanagement.gke.io
spec:
  group: hierarchycontroller.configmanagement.gke.io
  names:
    kind: HierarchicalResourceQuota
    listKind: HierarchicalResourceQuotaList
    plural: hierarchicalresourcequotas
    shortNames:
    - hrq
    singular: hierarchicalresourcequota
  scope: Namespaced
  versions:
  - name: v1alpha1
    schema:
      openAPIV3Schema:
        description: HierarchicalResourceQuota sets aggregate quota restrictions enforced
          for a namespace and descendant namespaces
        properties:
          apiVersion:
            description: 'APIVersion defines the versioned schema of this representation
              of an object. Servers should convert recognized schemas to the latest
              internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
            type: string
          kind:
            description: 'Kind is a string value representing the REST resource this
              object represents. Servers may infer this from the endpoint the client
              submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
            type: string
          metadata:
            type: object
          spec:
            description: Spec defines the desired quota
            properties:
              hard:
                additionalProperties:
                  anyOf:
                  - type: integer
                  - type: string
                  pattern: ^(\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))))?$
                  x-kubernetes-int-or-string: true
                description: Hard is the set of desired hard limits for each named
                  resource
                type: object
            type: object
          status:
            description: Status defines the actual enforced quota and its current
              usage
            properties:
              hard:
                additionalProperties:
                  anyOf:
                  - type: integer
                  - type: string
                  pattern: ^(\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))))?$
                  x-kubernetes-int-or-string: true
                description: Hard is the set of enforced hard limits for each named
                  resource
                type: object
              used:
                additionalProperties:
                  anyOf:
                  - type: integer
                  - type: string
                  pattern: ^(\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))))?$
                  x-kubernetes-int-or-string: true
                description: Used is the current observed total usage of the resource
                  in the namespace and its descendant namespaces.
                type: object
            type: object
        type: object
    served: true
    storage: true
status:
  acceptedNames:
    kind: ""
    plural: ""
  conditions: []
  storedVersions: []
---
apiVersion: admissionregistration.k8s.io/v1
kind: MutatingWebhookConfiguration
metadata:
  creationTimestamp: null
  labels:
    extensions.hierarchycontroller.configmanagement.gke.io: "true"
    hierarchycontroller.configmanagement.gke.io: "true"
  name: gke-hc-mutating-webhook-configuration
webhooks:
- admissionReviewVersions:
  - v1
  - v1beta1
  clientConfig:
    service:
      name: gke-hc-webhook-service
      namespace: hnc-system
      path: /mutate-podlabel
  failurePolicy: Ignore
  name: podlabel.hierarchycontroller.configmanagement.gke.io
  namespaceSelector:
    matchExpressions:
    - key: hierarchycontroller.configmanagement.gke.io
      operator: NotIn
      values:
      - "true"
  rules:
  - apiGroups:
    - ""
    apiVersions:
    - v1
    operations:
    - CREATE
    resources:
    - pods
  sideEffects: None
  timeoutSeconds: 2
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  labels:
    extensions.hierarchycontroller.configmanagement.gke.io: "true"
    hierarchycontroller.configmanagement.gke.io: "true"
    rbac.authorization.k8s.io/aggregate-to-admin: "true"
  name: gke-hc-hierarchicalresourcequota-editor-role
rules:
- apiGroups:
  - hierarchycontroller.configmanagement.gke.io
  resources:
  - hierarchicalresourcequotas
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - hierarchycontroller.configmanagement.gke.io
  resources:
  - hierarchicalresourcequotas/status
  verbs:
  - get
  - patch
  - update
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  labels:
    extensions.hierarchycontroller.configmanagement.gke.io: "true"
    hierarchycontroller.configmanagement.gke.io: "true"
    rbac.authorization.k8s.io/aggregate-to-view: "true"
  name: gke-hc-hierarchicalresourcequota-viewer-role
rules:
- apiGroups:
  - hierarchycontroller.configmanagement.gke.io
  resources:
  - hierarchicalresourcequotas
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - hierarchycontroller.configmanagement.gke.io
  resources:
  - hierarchicalresourcequotas/status
  verbs:
  - get
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  creationTimestamp: null
  labels:
    extensions.hierarchycontroller.configmanagement.gke.io: "true"
    hierarchycontroller.configmanagement.gke.io: "true"
  name: gke-hc-manager-role
rules:
- apiGroups:
  - ""
  resources:
  - namespaces
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - ""
  resources:
  - resourcequotas
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - ""
  resources:
  - secrets
  verbs:
  - get
  - list
  - update
  - watch
- apiGroups:
  - admissionregistration.k8s.io
  resources:
  - mutatingwebhookconfigurations
  verbs:
  - get
  - list
  - update
  - watch
- apiGroups:
  - admissionregistration.k8s.io
  resources:
  - validatingwebhookconfigurations
  verbs:
  - get
  - list
  - update
  - watch
- apiGroups:
  - hierarchycontroller.configmanagement.gke.io
  resources:
  - hierarchicalresourcequotas
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - hierarchycontroller.configmanagement.gke.io
  resources:
  - hierarchicalresourcequotas/status
  verbs:
  - get
  - patch
  - update
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  labels:
    extensions.hierarchycontroller.configmanagement.gke.io: "true"
    hierarchycontroller.configmanagement.gke.io: "true"
  name: gke-hc-proxy-role
rules:
- apiGroups:
  - authentication.k8s.io
  resources:
  - tokenreviews
  verbs:
  - create
- apiGroups:
  - authorization.k8s.io
  resources:
  - subjectaccessreviews
  verbs:
  - create
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  labels:
    extensions.hierarchycontroller.configmanagement.gke.io: "true"
    hierarchycontroller.configmanagement.gke.io: "true"
  name: gke-hc-manager-rolebinding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: gke-hc-manager-role
subjects:
- kind: ServiceAccount
  name: default
  namespace: hnc-system
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  labels:
    extensions.hierarchycontroller.configmanagement.gke.io: "true"
    hierarchycontroller.configmanagement.gke.io: "true"
  name: gke-hc-proxy-rolebinding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: gke-hc-proxy-role
subjects:
- kind: ServiceAccount
  name: default
  namespace: hnc-system
---
apiVersion: v1
kind: Secret
metadata:
  labels:
    extensions.hierarchycontroller.configmanagement.gke.io: "true"
    hierarchycontroller.configmanagement.gke.io: "true"
  name: gke-hc-webhook-server-cert
  namespace: hnc-system
---
apiVersion: v1
kind: Service
metadata:
  labels:
    control-plane: gke-hc-controller-manager
    extensions.hierarchycontroller.configmanagement.gke.io: "true"
    hierarchycontroller.configmanagement.gke.io: "true"
  name: gke-hc-controller-manager-metrics-service
  namespace: hnc-system
spec:
  ports:
  - name: https
    port: 8443
    targetPort: https
  selector:
    control-plane: gke-hc-controller-manager
    extensions.hierarchycontroller.configmanagement.gke.io: "true"
    hierarchycontroller.configmanagement.gke.io: "true"
---
apiVersion: v1
kind: Service
metadata:
  labels:
    extensions.hierarchycontroller.configmanagement.gke.io: "true"
    hierarchycontroller.configmanagement.gke.io: "true"
  name: gke-hc-webhook-service
  namespace: hnc-system
spec:
  ports:
  - port: 443
    targetPort: 10250
  selector:
    control-plane: gke-hc-controller-manager
    extensions.hierarchycontroller.configmanagement.gke.io: "true"
    hierarchycontroller.configmanagement.gke.io: "true"
---
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    control-plane: gke-hc-controller-manager
    extensions.hierarchycontroller.configmanagement.gke.io: "true"
    hierarchycontroller.configmanagement.gke.io: "true"
  name: gke-hc-controller-manager
  namespace: hnc-system
spec:
  replicas: 1
  selector:
    matchLabels:
      control-plane: gke-hc-controller-manager
      extensions.hierarchycontroller.configmanagement.gke.io: "true"
      hierarchycontroller.configmanagement.gke.io: "true"
  template:
    metadata:
      annotations:
        prometheus.io/scrape: "true"
      labels:
        control-plane: gke-hc-controller-manager
        extensions.hierarchycontroller.configmanagement.gke.io: "true"
        hierarchycontroller.configmanagement.gke.io: "true"
        monitored: "true"
    spec:
      containers:
      - args:
        - --metrics-addr=127.0.0.1:8080
        - --max-reconciles=10
        - --cert-restart-on-secret-refresh
        - --enable-hrq
        - --enable-pod-tree-labels
        command:
        - /manager
        image: gcr.io/config-management-release/gke-hc-manager:v0.11.0-hc.2
        name: manager
        ports:
        - containerPort: 10250
          name: webhook-server
          protocol: TCP
        - containerPort: 8080
          name: metrics
          protocol: TCP
        resources:
          limits:
            cpu: 100m
            memory: 100Mi
          requests:
            cpu: 100m
            memory: 50Mi
        volumeMounts:
        - mountPath: /tmp/k8s-webhook-server/serving-certs
          name: cert
          readOnly: true
      securityContext:
        fsGroup: 2000
        runAsNonRoot: true
        runAsUser: 1000
      terminationGracePeriodSeconds: 10
      volumes:
      - name: cert
        secret:
          defaultMode: 420
          secretName: gke-hc-webhook-server-cert
---
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  creationTimestamp: null
  labels:
    extensions.hierarchycontroller.configmanagement.gke.io: "true"
    hierarchycontroller.configmanagement.gke.io: "true"
  name: gke-hc-validating-webhook-configuration
webhooks:
- admissionReviewVersions:
  - v1
  - v1beta1
  clientConfig:
    service:
      name: gke-hc-webhook-service
      namespace: hnc-system
      path: /validate-hnc-gke-io-v1alpha1-hrq
  failurePolicy: Fail
  name: hrq.hierarchycontroller.configmanagement.gke.io
  rules:
  - apiGroups:
    - hierarchycontroller.configmanagement.gke.io
    apiVersions:
    - v1alpha1
    operations:
    - CREATE
    - UPDATE
    resources:
    - hierarchicalresourcequotas
  sideEffects: None
- admissionReviewVersions:
  - v1
  - v1beta1
  clientConfig:
    service:
      name: gke-hc-webhook-service
      namespace: hnc-system
      path: /validate-hnc-gke-io-v1alpha1-resourcequotasstatus
  failurePolicy: Ignore
  name: resourcesquotasstatus.hierarchycontroller.configmanagement.gke.io
  rules:
  - apiGroups:
    - ""
    apiVersions:
    - v1
    operations:
    - UPDATE
    resources:
    - resourcequotas/status
  sideEffects: None
  timeoutSeconds: 2
---

# ----- hnc-psp.yaml -----
# ----- hnc-psp.yaml -----
# Hierarchy Controller PSP
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  creationTimestamp: null
  name: configmanagement.gke.io:hierarchy-controller-psp
  labels:
    hierarchycontroller.configmanagement.gke.io: "true"
rules:
  - apiGroups:
      - policy
    resources:
      - podsecuritypolicies
    resourceNames:
      - acm-psp
    verbs:
      - use
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: configmanagement.gke.io:hierarchy-controller-psp
  labels:
    hierarchycontroller.configmanagement.gke.io: "true"
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: configmanagement.gke.io:hierarchy-controller-psp
subjects:
  - kind: ServiceAccount
    name: default
    namespace: hnc-system
---

